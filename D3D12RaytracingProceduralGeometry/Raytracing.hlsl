
#ifndef RAYTRACING_HLSL
#define RAYTRACING_HLSL

#define HLSL
#include "RaytracingHlslCompat.h"
#include "ProceduralPrimitivesLibrary.hlsli"
#include "RaytracingShaderHelper.hlsli"

//***************************************************************************
//*****------ Shader resources bound via root signatures -------*************
//***************************************************************************

// Scene wide resources.
//  g_* - bound via a global root signature.
//  l_* - bound via a local root signature.
RaytracingAccelerationStructure g_scene : register(t0, space0);
RWTexture2D<float4> g_renderTarget : register(u0);
RWTexture2D<float4> g_rasterTarget : register(u1);

RWStructuredBuffer<Photon> photonBuffer : register(u2);
RWByteAddressBuffer photonBufferCounter : register(u3);
//RWStructuredBuffer<uint> tiledPhotonMap : register(u9);

RWTexture2D<float4> GBufferBRDF : register(u4);
RWTexture2D<float4> GBufferPosition : register(u5);
RWTexture2D<float4> GBufferNormal : register(u6);
RWTexture2D<float4> staging : register(u7);
RWTexture2D<uint> stagingTarget_R : register(u8);
RWTexture2D<uint> stagingTarget_G : register(u9);
RWTexture2D<uint> stagingTarget_B : register(u10);

RWTexture2D<float4> accumulationLight : register(u11);
RWTexture2D<float4> accumulationForward : register(u12);
RWTexture2D<float4> lightTracingPhotons [MAX_RAY_RECURSION_DEPTH*4]: register(u13);



ConstantBuffer<SceneConstantBuffer> g_sceneCB : register(b0);



// Triangle resources
ByteAddressBuffer g_indices : register(t1, space0);
StructuredBuffer<Vertex> g_vertices : register(t2, space0);

// Procedural geometry resources
StructuredBuffer<PrimitiveInstancePerFrameBuffer> g_AABBPrimitiveAttributes : register(t3, space0);
StructuredBuffer<CSGNode> csgTree : register(t4, space0);

ConstantBuffer<PrimitiveConstantBuffer> l_materialCB : register(b1);
ConstantBuffer<PrimitiveInstanceConstantBuffer> l_aabbCB: register(b2);

groupshared uint photonSharedIndex = 0;

// Functions for PRNG
// http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
static uint rng_state;
//static const uint photonCount = 1000;
static const float TWO_PI = 6.2831853071795864769252867665590057683943f;
static const float INV_PI = 0.318309886f;

static const float PI = 3.1415926535897932384626422832795028841971f;
static const float SQRT_OF_ONE_THIRD = 0.5773502691896257645091487805019574556476f;

static const float prng_01_convert = (1.0f / 4294967296.0f); // Convert numbers generated by rand_xorshift to be between 0, 1

float2 hash2(inout float seed) {
    return frac(sin(float2(seed += 0.1, seed += 0.1)) * float2(43758.5453123, 22578.1459123));
}



float rand_xorshift()
{
    // Xorshift algorithm from George Marsaglia's paper
    rng_state ^= uint(rng_state << 13);
    rng_state ^= uint(rng_state >> 17);
    rng_state ^= uint(rng_state << 5);
    return rng_state * prng_01_convert;
}

uint wang_hash_original(uint seed)
{
    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}

float seed_xorshift(inout uint seed)
{
    // Xorshift algorithm from George Marsaglia's paper
    seed ^= uint(seed << 13);
    seed ^= uint(seed >> 17);
    seed ^= uint(seed << 5);
    return seed * prng_01_convert;
}

float3x3 GetTangentSpace(float3 normal)
{
    // Choose a helper vector for the cross product
    float3 helper = float3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
        helper = float3(0, 0, 1);
    // Generate vectors
    float3 tangent = normalize(cross(normal, helper));
    float3 binormal = normalize(cross(normal, tangent));
    return float3x3(tangent, binormal, normal);
}



float3 SampleHemisphere(float3 normal, inout float seed)
{
    // Uniformly sample hemisphere direction
    float cosTheta = rand_xorshift();
    float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));
    float phi = 2 * PI * rand_xorshift();
    float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
    // Transform direction to world space
    return mul(tangentSpaceDir, GetTangentSpace(normal));
}

float3 calculateRandomDirectionInHemisphereSeedShift(in float3 normal, inout uint seed) {

    float up = sqrt(seed_xorshift(seed)); // cos(theta)
    float over = sqrt(1 - up * up); // sin(theta)
    float around = seed_xorshift(seed) * TWO_PI;

    // Find a direction that is not the normal based off of whether or not the
    // normal's components are all equal to sqrt(1/3) or whether or not at
    // least one component is less than sqrt(1/3). Learned this trick from
    // Peter Kutz.

    float3 directionNotNormal;
    if (abs(normal.x) < SQRT_OF_ONE_THIRD) {
        directionNotNormal = float3(1, 0, 0);
    }
    else if (abs(normal.y) < SQRT_OF_ONE_THIRD) {
        directionNotNormal = float3(0, 1, 0);
    }
    else {
        directionNotNormal = float3(0, 0, 1);
    }

    // Use not-normal direction to generate two perpendicular directions
    float3 perpendicularDirection1 =
        normalize(cross(normal, directionNotNormal));
    float3 perpendicularDirection2 =
        normalize(cross(normal, perpendicularDirection1));

    return up * normal
        + cos(around) * over * perpendicularDirection1
        + sin(around) * over * perpendicularDirection2;
}



float3 calculateRandomDirectionInHemisphere(in float3 normal) {

    float up = sqrt(rand_xorshift()); // cos(theta)
    float over = sqrt(1 - up * up); // sin(theta)
    float around = rand_xorshift() * TWO_PI;

    // Find a direction that is not the normal based off of whether or not the
    // normal's components are all equal to sqrt(1/3) or whether or not at
    // least one component is less than sqrt(1/3). Learned this trick from
    // Peter Kutz.

    float3 directionNotNormal;
    if (abs(normal.x) < SQRT_OF_ONE_THIRD) {
        directionNotNormal = float3(1, 0, 0);
    }
    else if (abs(normal.y) < SQRT_OF_ONE_THIRD) {
        directionNotNormal = float3(0, 1, 0);
    }
    else {
        directionNotNormal = float3(0, 0, 1);
    }

    // Use not-normal direction to generate two perpendicular directions
    float3 perpendicularDirection1 =
        normalize(cross(normal, directionNotNormal));
    float3 perpendicularDirection2 =
        normalize(cross(normal, perpendicularDirection1));

    return up * normal
        + cos(around) * over * perpendicularDirection1
        + sin(around) * over * perpendicularDirection2;
}
float3 SampleHemisphereSeedShift(float3 normal, inout float seed)
{
    // Uniformly sample hemisphere direction

    float cosTheta = seed_xorshift(seed);
    float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));
    float phi = 2 * PI * seed_xorshift(seed);
    float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
    // Transform direction to world space
    return mul(tangentSpaceDir, GetTangentSpace(normal));
}




inline float3 SquareToSphereUniform(float2 samplePoint)
{
    float radius = 1.f;

    float phi = samplePoint.y * PI;
    float theta = samplePoint.x * TWO_PI;

    float3 result;
    result.x = radius * cos(theta) * sin(phi);
    result.y = radius * cos(phi);
    result.z = radius * sin(theta) * sin(phi);
    return result;
}

float3 lambertian(float3 normal, float3 pos, float3 materialColour) {
    //float3 lightDir =  normalize(g_sceneCB.lightPosition.xyz - pos);
    float3 lightDir = normalize(g_sceneCB.lightSphere.xyz - pos);
    float3 colour = materialColour*g_sceneCB.lightPower / M_PI * max(0.f, dot(normal, lightDir));
    return  colour;
}

float rand_ik(inout uint seed)
{
    float result = frac(sin(seed / 100.0f * dot(DispatchRaysIndex().xy, float2(12.9898f, 78.233f))) * 43758.5453f);
    seed += 1.0f;
    return result;
}

float3 cosWeightedRandomHemisphereDirection(const float3 n, inout float seed) {
    float2 r = hash2(seed);

    float3  uu = normalize(cross(n, float3(0.0, 1.0, 1.0)));
    float3  vv = cross(uu, n);

    float ra = sqrt(r.y);
    float rx = ra * cos(6.2831 * r.x);
    float ry = ra * sin(6.2831 * r.x);
    float rz = sqrt(1.0 - r.y);
    float3  rr = float3(rx * uu + ry * vv + rz * n);

    return normalize(rr);
}


float3 randomSphereDirection(inout float seed) {
    float2 h = hash2(seed) * float2(2., 6.28318530718) - float2(1, 0);
    float phi = h.y;
    return float3(sqrt(1. - h.x * h.x) * float2 (sin(phi), cos(phi)), h.x);
}


float3 sampleLight(const in float3 ro, inout float seed) {
    float3 n = randomSphereDirection(seed) * g_sceneCB.lightSphere.w;
    return g_sceneCB.lightSphere.xyz + n;
}








float orenNayar(float3 v, float3 light, float3 normal, float roughness) {

    float roughness2 = roughness * roughness;
    float2 oren_nayar_fraction = roughness2 / (roughness2 + float2(0.33, 0.09));
    float2 oren_nayar = float2(1, 0) + float2(-0.5, 0.45) * oren_nayar_fraction;

    float2 cos_theta = saturate(float2(dot(normal, light), dot(normal, v)));
    float2 cos_theta2 = cos_theta * cos_theta;
    float sin_theta = sqrt((1 - cos_theta2.x) * (1 - cos_theta2.y));
    float3 light_plane = normalize(light - cos_theta.x * normal);
    float3 view_plane = normalize(v - cos_theta.y * normal);
    float cos_phi = saturate(dot(light_plane, view_plane));

    float diffuse_oren_nayar = cos_phi * sin_theta / max(cos_theta.x, cos_theta.y);
    float diffuse = cos_theta.x * (oren_nayar.x + oren_nayar.y * diffuse_oren_nayar);

    return diffuse;
}


float Fresnel(float3 wi, float3 normal, float3 eta) {
    float cosIncident = clamp(-1, 1, dot(wi, normal));
    float etaI = 1, etaT = eta;
    if (cosIncident > 0) {
        float temp = etaT;
        etaT = etaI;
        etaI = temp;
    }

    float sinT = etaI / etaT * sqrt(max(0.0f, 1 - cosIncident * cosIncident));

    if (sinT >= 1) {

        //total internal reflection, return probability of reflection = 1
        return 1;
    }
    else {
        float cosT = sqrt(max(0.0f, 1 - sinT * sinT));
        float cosI = abs(cosIncident);
        float Rs = ((etaT * cosI) - (etaI * cosT)) / ((etaT * cosI) + (etaI * cosT));
        float Rp = ((etaI * cosI) - (etaT * cosT)) / ((etaI * cosI) + (etaT * cosT));

        float fresn = (Rs * Rs + Rp * Rp) / 2;
        return fresn;
    }
}

float rand(in float2 uv) {
    float2 noise = (frac(sin(dot(uv, float2(12.9898, 78.233) * 2.0)) * 43758.5453));
    return abs(noise.x + noise.y) * 0.5;
}

float3 randomDirection(float2 ra) {
    float theta_0 = 2 * M_PI * rand(ra);
    float theta_1 = acos(1 - 2 * rand(ra));
    float3 dir = float3(sin(theta_0) * sin(theta_1), sin(theta_0)*cos(theta_1), sin(theta_1));
    return dir;
}



inline float3 SquareToDiskConcentric(in float2 sample)
{
    // Used Peter Shirley's concentric disk warp
    float radius;
    float angle;
    float a = (2 * sample[0]) - 1;
    float b = (2 * sample[1]) - 1;

    if (a > -b) {
        if (a > b) {
            radius = a;
            angle = (PI / 4.f) * (b / a);
        }
        else {
            radius = b;
            angle = (PI / 4.f) * (2 - (a / b));
        }
    }
    else {
        if (a < b) {
            radius = -a;
            angle = (PI / 4.f) * (4 + (b / a));
        }
        else {
            radius = -b;
            if (b != 0) {
                angle = (PI / 4.f) * (6 - (a / b));
            }
            else {
                angle = 0;
            }
        }
    }
    return float3(radius * cos(angle), radius * sin(angle), 0);
}

inline float3 SquareToHemisphereCosine(in float2 sample)
{
    // Used Peter Shirley's cosine hemisphere
    float3 disk = SquareToDiskConcentric(sample);
    return float3(disk[0], disk[1], sqrt(1.f - pow(length(disk), 2.f)));
}


inline float AbsCosTheta(in float3 w) {
    return abs(w.z);
}

inline bool SameHemisphere(in float3 w, in float3 wp) {
    return w.z * wp.z > 0;
}

inline float3 Lambert_Sample_f(in float3 wo, out float3 wi, in float2 samplePt, out float pdf, in float3 albedo) {
    wi = SquareToHemisphereCosine(samplePt);
    if (wo.z < 0) wi.z *= -1;
    wi = normalize(wi);
    pdf = SameHemisphere(wo, wi) ? INV_PI * AbsCosTheta(wi) : 0;

    return INV_PI * albedo;
}

float reflectionBRDF(float3 incomingDirection, float3 normal) {
    float3 n_in = normalize(-incomingDirection);
    float3 outgoing = reflect(n_in, normal);

    float thetaI = atan(n_in.y / n_in.x);
    float phiI = acos(n_in.z);


    float thetaO = atan(outgoing.y / outgoing.x);
    float phiO = acos(outgoing.z);

    float f_rs = 2 * (sin(thetaO) * sin(thetaO) - sin(thetaI) * sin(thetaI)) * (phiO - phiI);
    return f_rs;
}

float FresnelAmount(float n1, float n2, float3 normal, float3 incident) {
    float r0 = (n1 - n2) / (n1 + n2);
    r0 *= r0;
    float cosx = -dot(normal, incident);
    if (n1 > n2) {
        float n = n1 / n2;
        float sint = n * n*(1.0f - cosx * cosx);

        if (sint > 1.0) {
            return 1.0;
        }
        cosx = sqrt(1.0 - sint);
    }
    float x = 1.0 - cosx;
    float ret = r0 + (1.0f - r0) * x * x * x * x * x;
    ret = (l_materialCB.reflectanceCoef + (1.0 - l_materialCB.reflectanceCoef) * ret);
    return ret;
}


float PhongLighting(float3 normal, bool shadowHit) {
    float3 position = HitWorldPosition();
    float3 lightDir = normalize(g_sceneCB.lightSphere.xyz - position);
    float3 viewDir = normalize(-WorldRayDirection());
    float3 refl = normalize(reflect(normal, lightDir));
    float illum;
    if (l_materialCB.refractiveCoef == 0) {
         illum = l_materialCB.diffuseCoef * saturate(dot(lightDir, normal));

        illum += l_materialCB.specularCoef * pow(saturate(dot(refl,viewDir)), l_materialCB.specularPower);
    }
    else {
        illum = l_materialCB.specularCoef * pow(saturate(dot(refl, viewDir)), l_materialCB.specularPower);

    }
    if (!shadowHit) {

    }
    else {
       //llum = 0;

    }
    return illum;
}

bool refractTest(float3 v, float3 normal, float index, inout float3 refracted) {
    float dt = dot(v, normal);
    float discriminant = 1.0 - index * index * (1 - dt * dt);
    if (discriminant > 0) {
        refracted = index * (v - normal * dt) - normal * sqrt(discriminant);
        return true;
    }
    else {
        return false;
    }
}

PhotonPayload TracePhotonRay(in Ray ray, in PhotonPayload payload) {
    if (payload.recursionDepth >= MAX_RAY_RECURSION_DEPTH) {
        return payload;
    }

    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    // Set TMin to a zero value to avoid aliasing artifacts along contact areas.
    // Note: make sure to enable face culling so as to avoid surface face fighting.
    rayDesc.TMin = 0.000001;
    rayDesc.TMax = 10000;

    payload.recursionDepth += 1;

    TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Radiance],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Radiance],
        rayDesc, payload);

    return payload;
}

// Trace a radiance ray into the scene and returns a shaded color.
RayPayload TraceRadianceRay(in Ray ray, in RayPayload payload)
{
    if (payload.recursionDepth >= MAX_RAY_RECURSION_DEPTH)
    {
       payload.color = float4(0,0,0,0);
       return payload;
    }

    // Set the ray's extents.
    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    // Set TMin to a zero value to avoid aliasing artifacts along contact areas.
    // Note: make sure to enable face culling so as to avoid surface face fighting.
    rayDesc.TMin = 1;
    rayDesc.TMax = 10000;
  
    payload.recursionDepth += 1;

    TraceRay(g_scene, RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Radiance],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Radiance],
        rayDesc, payload);

    return payload;
}



bool ShadowRay(in Ray ray, in UINT currentRayRecursionDepth) {

    if (currentRayRecursionDepth >= MAX_RAY_RECURSION_DEPTH)
    {
        return false;
    }


    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    rayDesc.TMin = 0.0001;
    rayDesc.TMax = 10000;

    ShadowRayPayload shadow = { true };

    TraceRay(g_scene,
         RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Shadow],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Shadow],
        rayDesc, shadow);

    return shadow.hit;
}

inline void GetPixelPosition(float3 rayHitPosition, float2 screenDim, out uint2 pixelIndex, out bool inRange)
{
    float4 clippingCoord = mul(float4(rayHitPosition, 1), g_sceneCB.projection);
    clippingCoord.xyz /= clippingCoord.w;

    if (clippingCoord.z <= 0.01f || clippingCoord.z >= 1 || clippingCoord.x <= -1 || clippingCoord.x >= 1 || clippingCoord.y <= -1 || clippingCoord.y >= 1) {
        inRange = false;
        return;
    }

    inRange = true;
    pixelIndex.x = ((clippingCoord.x + 1.0) * 0.5f) * screenDim.x;
    pixelIndex.y = ((1.0 - clippingCoord.y) * 0.5f) * screenDim.y;
}



uint wang_hasher(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}
uint wang_hash(uint seed, int x , int y)
{
    seed = seed + 76.897898 * 48.789789 * cos(x) * sin(y) * 20.79797;
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}
float chessBoard(float3 pos) {

    float chess = floor(sqrt(pos.x * pos.x + pos.z * pos.z)) + floor(atan(pos.z / pos.x));
   // chess = floor(pos.x) +  floor(pos.z);
    chess = frac(chess * 0.5);
    chess *= 2;
    if (chess == 0.0) {
        chess = 0.5;
    }
    return chess;
}
float chessSides(float3 pos) {

    float chess = floor(sqrt(pos.x * pos.x + pos.z * pos.z)) + floor(atan(pos.z / pos.x));
    chess = floor(pos.x) +  floor(pos.z);
    chess = frac(chess * 0.5);
    chess *= 2;
    if (chess == 0.0) {
        chess = 0.0;
    }
    return chess;
}

float3 getColour(float3 nDir) {
    float3 dir = normalize(WorldRayDirection());
    float t = 0.5 * (dir.y + 1.0);
    return (1.0 - t) * float3(1.0, 1.0, 1.0) + t * float3(0.52941176471, 0.80784313725, 0.98039215686);
}

inline void VisualizePhotonBuffer(float2 screenDims)
{
    // Get the Hit location of the photon
    for (int i = 0; i < 100; i++) {
        float3 hitPosition = photonBuffer[i].position.xyz;

        // Find the Screen Space Coord for the photon
        uint2 pixelPos;
        bool inRange;

        GetPixelPosition(hitPosition, screenDims, pixelPos, inRange);

        if (!inRange) {
            return;
        }

        // Shadow Ray.
        RayDesc ray;
        ray.Origin = hitPosition;
        //ray.Direction = normalize(g_sceneCB.cameraPosition.xyz - hitPosition);
        ray.Direction = g_sceneCB.cameraPosition.xyz - hitPosition;
        ray.TMin = 0.001;
        ray.TMax = 1.001;

        Ray r = { hitPosition, g_sceneCB.cameraPosition.xyz - hitPosition };
        ShadowRayPayload shadow = { true };


        TraceRay(g_scene,
            RAY_FLAG_CULL_BACK_FACING_TRIANGLES
            // ~skip any hit shaders
            | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
            TraceRayParameters::InstanceMask,
            TraceRayParameters::HitGroup::Offset[RayType::Shadow],
            TraceRayParameters::HitGroup::GeometryStride,
            TraceRayParameters::MissShader::Offset[RayType::Shadow],
            ray, shadow);

        if (!shadow.hit) {
            float2 tempPixel = pixelPos;
            tempPixel /= screenDims;
            g_renderTarget[pixelPos] += float4(hitPosition, 0)*100;
        }
    }

}
inline void VisualizePhoton(float4 photon, float4 colour, float2 screenDims)
{
    // Get the Hit location of the photon
    float3 hitPosition = photon.xyz;

    // Find the Screen Space Coord for the photon
    uint2 pixelPos;
    bool inRange;
    GetPixelPosition(hitPosition, screenDims, pixelPos, inRange);

    if (!inRange) {
        return;
    }

    // Shadow Ray.
    RayDesc ray;
    ray.Origin = hitPosition;
    //ray.Direction = normalize(g_sceneCB.cameraPosition.xyz - hitPosition);
    ray.Direction = g_sceneCB.cameraPosition.xyz - hitPosition;
    ray.TMin = 0.001;
    ray.TMax = 1.001;

    Ray r = { hitPosition, g_sceneCB.cameraPosition.xyz - hitPosition };
    ShadowRayPayload shadow = { true };
   

    TraceRay(g_scene,
        RAY_FLAG_CULL_BACK_FACING_TRIANGLES
        // ~skip any hit shaders
        | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Shadow],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Shadow],
        ray, shadow);
    
    if (!shadow.hit) {
        float2 tempPixel = pixelPos;
        tempPixel /= screenDims;
        g_renderTarget[pixelPos] = colour*1000;
    }

}

inline void GetTileIndex(float3 rayHitPosition, out uint tileIndex) {

    uint width, height;
    g_renderTarget.GetDimensions(width, height);

    float2 screenDim = float2(width, height);

    uint2 pixelIndex;
    bool inRange;
    GetPixelPosition(rayHitPosition, screenDim, pixelIndex, inRange);

    //suppose a tile is 64*64 pixels
    //order tiles in the following way
    //|1|2|3|4|
    //|5|6|7|8|
    //|9|10...|
    //|. .
    //|.   .
    //|.     .

    //classify pixel index
}

[shader("raygeneration")]
void CompositeRayGen() {
    //add corresponding RTVs together.
    uint2 index = DispatchRaysIndex().xy;
    g_renderTarget[index] += g_rasterTarget[index];
   /* for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            uint2 i = uint2(dx, dy);
            g_renderTarget[index] += g_renderTarget[i];
        }
    }

    g_renderTarget[index] = normalize(g_renderTarget[index]);*/
   // g_renderTarget[index] += float4(1, 1, 0, 0);
    //g_rasterTarget[index] = float4(1, 1, 0, 0);
    //
  //  g_rasterTarget[index] = g_renderTarget[index];
    //g_renderTarget[index] += g_rasterTarget[index];

}

[shader("closesthit")]
void CompositeHit(inout RayPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr) {
    //add corresponding RTVs together.
}
[shader("miss")]
void CompositeMiss(inout RayPayload rayPayload) {
    //add corresponding RTVs together.
}
[shader("raygeneration")]
void Photon_Ray_Gen() {

    //g_renderTarget[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
  /* for (int i = 0; i < 6; i++) {
        screenSpacePhoton[i][DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
        screenSpacePhotonColour[i][DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
        screenSpacePhotonDirection[i][DispatchRaysIndex().xy] = float4(0, 0, 0, 0);

    }*/
  //  photonBufferCounter.Store(0, 0);
    //AllMemoryBarrierWithGroupSync();

    float accumulatedFrames = g_sceneCB.accumulatedFrames;
    //uint ran = uint(uint(samplePoint.x) * uint(1973) + uint(samplePoint.y) * uint(9277) + uint(g_sceneCB.accumulatedFrames) * uint(26699)) | uint(1);

        // float3 direction = randomDirection(DispatchRaysIndex().xy + i);
    float seed = DispatchRaysIndex().x + DispatchRaysIndex().y * 3.43121412313 + frac(1.12345314312 * g_sceneCB.frameNumber);
   

    float2 samplePoint = DispatchRaysIndex().xy;

  
    UINT currentRecursionDepth = 0;

 
    uint width, height;
    g_renderTarget.GetDimensions(width, height);
    float2 screenDims = float2(width, height);

    float power = 1/(width * height); //number of photons to be emitted

    PhotonPayload payload = { float4(0,0,0,0), g_sceneCB.lightDiffuseColor*2*INV_PI,
     power, 1, 0 };


    for (int i = 0; i < 1; i++) {
       // float3 direction = randomDirection(DispatchRaysIndex().xy + i);
        // = uint(wang_hash_original(samplePoint.x + i + DispatchRaysDimensions().x * samplePoint.y));
        rng_state = uint(wang_hash_original(DispatchRaysIndex().x + DispatchRaysDimensions().x * DispatchRaysIndex().y) );

    //    float2 rany = float2(rand_ik(rng_state), rand_ik(rng_state));
        payload.seed = rng_state;
        float2 random = float2(rand_xorshift(), rand_xorshift());
        float3 dir = SquareToSphereUniform(random);
       // float3 ro = randomSphereDirection(seed);
        //float3 ro = randomSphereDirection(rng_state);
        //float3 rd = cosWeightedRandomHemisphereDirection(ro, rng_state);

        float3 ro = g_sceneCB.lightSphere.xyz;    // float2 r = rand_xor(ran);
//        float2 randi = float2(wang_hash_original(ran), wang_hash_original(ran));
        float3 origin = ro;
        //float3 dir = normalize(SquareToSphereUniform(rany));

        Ray ray = { ro,dir };
       // float3 origin = g_sceneCB.lightPosition;
        //float3 dir = normalize(SquareToSphereUniform(rany));
      //  float2 rand = float2(rand_xorshift(), rand_xorshift());
       // float3 dir = normalize(SquareToSphereUniform(rand));

     //   float3 origin = g_sceneCB.lightPosition;

        //Ray ray = { origin, dir };
        /*RayDesc ray;
        ray.Origin = origin;
        ray.Direction = dir;
        ray.TMin = 0.001;
        ray.TMax = 10000.0;


       // Ray r = GenerateCameraRay(DispatchRaysIndex().xy, g_sceneCB.cameraPosition.xyz, g_sceneCB.projectionToWorld);
       */
        

        PhotonPayload traced = TracePhotonRay(ray, payload);
        //VisualizePhoton(traced.position, screenDims);
        //VisualizePhotonBuffer(screenDims);
        //VisualizePhotonBuffer(traced, screenDims);
       // VisualizePhoton(traced, screenDims);
    }

 
    // Write the raytraced color to the output texture.
  //  g_renderTarget[DispatchRaysIndex().xy] = traced.color;
    //send random ray light source
   // g_renderTarget[DispatchRaysIndex().xy] = float4(0, 1, 0, 1);

}
 inline float maxValue(in float3 w) {
    return max(w.x, max(w.y, w.z));
}

inline bool inscreenSpace(float3 intersection, float2 uv) {
    uint width, height;
    g_renderTarget.GetDimensions(width, height);

    float2 screenDims = float2(width, height);

    bool inRange;
    GetPixelPosition(intersection, screenDims, uv, inRange);

    if (inRange) {
        return true;
    }
    return false;
}

[shader("miss")]
void Photon_Miss(inout PhotonPayload payload) {
    //g_renderTarget[DispatchRaysIndex().xy] = BackgroundColor;

}

[shader("miss")]
void Photon_Shadow_Miss(inout ShadowRayPayload payload) {
    payload.hit = false;
}


[shader("closesthit")]
void ClosestHit_Photon_Triangle(inout PhotonPayload payload, in BuiltInTriangleIntersectionAttributes attr) {

    float3 pos = HitWorldPosition();

    uint indexSizeInBytes = 4;
    uint indicesPerTriangle = 3;
    uint triangleIndexStride = indicesPerTriangle * indexSizeInBytes;
    uint baseIndex = PrimitiveIndex() * triangleIndexStride;
    uint index = InstanceID();
    // Load up three 16 bit indices for the triangle.
    const uint3 indices = Load3x16BitIndices(baseIndex, g_indices);

    // Retrieve corresponding vertex normals for the triangle vertices.
    float3 triangleNormals[3] = { g_vertices[indices[0]].normal,
                                   g_vertices[indices[1]].normal,
                                    g_vertices[indices[2]].normal
    };

    float raySize = sqrt(dot(pos - WorldRayOrigin(), pos - WorldRayOrigin()));
    float3 normal = HitAttribute(triangleNormals, attr.barycentrics);
    


    //compute cosine 
    float3 colour = payload.colour * l_materialCB.albedo;
    payload.colour = float4(colour, 1);
    float3 dir = normalize(WorldRayDirection());

    //compute path probability
    
    //if diffuse surface, store photon//(l_materialCB.reflectanceCoef <= 0.0f && l_materialCB.refractiveCoef <= 0 && payload.recursionDepth > 1
    if (l_materialCB.reflectanceCoef <= 0.0f && l_materialCB.refractiveCoef <= 0.0f && payload.recursionDepth > 1) {

    
        uint dstIndex = photonBuffer.IncrementCounter();
        Photon p = { float4(pos, raySize), float4(dir, 1), float4(colour, 1), float4(0, 1, 0, payload.probability)};

        if (dstIndex < PHOTON_COUNT) {
            photonBuffer[dstIndex] = p;
        }
        else {
           uint decr =  photonBuffer.DecrementCounter();
           return;

        }

    }

    float3 refractPos;
    float3 reflectPos;

    float maximumPower = maxValue(payload.colour);
  //  if (rand_xorshift() < (1.f - maximumPower)) {
    //    return;
    //}
    if (l_materialCB.refractiveCoef > 0) {
        //assume refractive glass
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, normal) > 0) {
            outwardNormal = -normal;
            index = n2;
        }
        else {
            outwardNormal = normal;
            index = n1 / n2;
        }
        if (refractTest(dir, outwardNormal, index, refracted)) {
            Ray r = { pos, refracted };
            refractPos =  TracePhotonRay(r, payload).position;
        }
        else {
            Ray r = { pos, reflect(dir, normal) };
            TracePhotonRay(r, payload);
            // refractionColour = TraceRadianceRay(r, rayPayload.recursionDepth);
        }
        float reflectMulti = FresnelAmount(n1, n2, normal, dir);
    }


    if (l_materialCB.reflectanceCoef > 0.1f) {
        Ray r = { pos, reflect(dir, normal) };
        //power of reflected photon should be scaled by the reflective property.
        payload.colour *= l_materialCB.reflectanceCoef;
        reflectPos = TracePhotonRay(r, payload).position;
    }
    else {
        uint seed = payload.seed;
        float2 randomSample = float2(seed_xorshift(seed), seed_xorshift(seed));
        payload.seed = seed;
        //uint seed = rayPayload.randomSeed;
        float3 dir = SquareToHemisphereCosine(randomSample);



       // float3 randDir = SampleHemisphere(normal, rng_state);
        Ray r = { pos, dir };
        TracePhotonRay(r, payload);
    }
}

//don't need to define custom interesctions, since we will use the same as backward ray-tracing
[shader("closesthit")]
void ClosestHit_Photon_Procedural(inout PhotonPayload payload, in ProceduralPrimitiveAttributes attr) {
    //payload.colour = l_materialCB.albedo;

    float3 pos = HitWorldPosition();

    float3 dir = normalize(WorldRayDirection());
    float3 refractPos;
    float3 reflectPos;
    //payload.colour = l_materialCB.albedo;
    float3 colour = l_materialCB.albedo.xyz*payload.colour.xyz;
    payload.colour = float4(colour, 1);

    if (l_materialCB.reflectanceCoef <= 0.0f && l_materialCB.refractiveCoef <= 0 && payload.recursionDepth >= 1) {

        uint dstIndex = photonBuffer.IncrementCounter();
        float raySize = sqrt(dot(pos - WorldRayOrigin(), pos - WorldRayOrigin()));

        Photon p = { float4(pos, raySize), float4(dir, 1), float4(colour, 1), float4(attr.normal, payload.probability) };
        if (dstIndex < PHOTON_COUNT) {
            photonBuffer[dstIndex] = p;
        }
        else {
            uint decr = photonBuffer.DecrementCounter();
            return;

        }
    }

    //russian roulette
    float maximumPower = maxValue(payload.colour);
    //  if (rand_xorshift() < (1.f - maximumPower)) {
      //    return;
      //}

    if (l_materialCB.reflectanceCoef > 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        Ray r = { pos, reflect(dir, attr.normal) };
        reflectPos = TracePhotonRay(r, payload).position;
    }
    else if (l_materialCB.refractiveCoef > 0.0f) {
        float fresnel = Fresnel(dir, attr.normal, l_materialCB.refractiveCoef);
        bool outside = dot(dir, attr.normal) < 0 ? false : true;
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, attr.normal) > 0) {
            outwardNormal = -attr.normal;
            index = n2;
        }
        else {
            outwardNormal = attr.normal;
            index = n1 / n2;
        }
        refractTest(dir, outwardNormal, index, refracted);
        if (fresnel < 1) {

            Ray r = { pos, refracted };
            float temp = payload.probability;
            payload.probability =  (1 - fresnel);

            refractPos = TracePhotonRay(r, payload).position;
            payload.probability = temp;
            //setup refracted ray

        }

        float3 reflected = normalize(reflect(dir, attr.normal));
        Ray r = { pos, reflected };
        payload.probability = (fresnel);
        refractPos = TracePhotonRay(r, payload).position;

        //hitColour += reflectionColour * fresnel + refractColour * (1 - fresnel);
    }
    else {

        uint seed = payload.seed;
        float2 randomSample = float2(seed_xorshift(seed), seed_xorshift(seed));
        payload.seed = seed;
        //uint seed = rayPayload.randomSeed;
        float3 dir = SquareToHemisphereCosine(randomSample);

        //uint seed = payload.seed;
        //float3 randDir = SampleHemisphere(attr.normal, seed);
        payload.probability = INV_PI;
        Ray r = { pos, dir };
        TracePhotonRay(r, payload);
    }
}

   


PathTracingPayload TraceForwardPath(in Ray ray, in PathTracingPayload payload)
{
  

    if (payload.recursionDepth >= MAX_RAY_RECURSION_DEPTH) {
        return payload;
    }
    // Set the ray's extents.
    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    // Set TMin to a zero value to avoid aliasing artifacts along contact areas.
    // Note: make sure to enable face culling so as to avoid surface face fighting.
    rayDesc.TMin = 0.001;
    rayDesc.TMax = 10000;

    payload.recursionDepth += 1;

        //need to generate a new seed given the current seed.

        //payload from intersection returns ray direction information, etc.

        //this is a bounce loop, so we're solving the intergral of the rendering equation

        //do some russian roulette
        //p = 1 - hemispherical reflectance of the material of the surface

        //diffuse = integral(emmisive*BRDF(surface point x, incoming, outgoing)*Visibility(x, y) - whether point y is visibile from point x
        //if the random bouncing ends up hitting the light, then the sample needs to be discared - this will never happen since we have a point light
        TraceRay(g_scene, RAY_FLAG_CULL_BACK_FACING_TRIANGLES ,
            TraceRayParameters::InstanceMask,
            TraceRayParameters::HitGroup::Offset[RayType::Radiance],
            TraceRayParameters::HitGroup::GeometryStride,
            TraceRayParameters::MissShader::Offset[RayType::Radiance],
            rayDesc, payload);
    

    return payload;
}



// "GPU Random Numbers via the Tiny Encryption Algorithm"
uint tea(uint val0, uint val1)
{
    uint v0 = val0;
    uint v1 = val1;
    uint s0 = 0;

    for (uint n = 0; n < 16; n++)
    {
        s0 += 0x9e3779b9;
        v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
        v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
    }

    return v0;
}



float RandomFloat01(inout uint state)
{
    return float(wang_hash_original(state)) / 4294967296.0;
}

float3 RandomUnitVector(inout uint state)
{
    float z = RandomFloat01(state) * 2.0f - 1.0f;
    float a = RandomFloat01(state) * TWO_PI;
    float r = sqrt(1.0f - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return float3(x, y, z);
}



// Generate a random unsigned int in [0, 2^24) given the previous RNG state
// using the Numerical Recipes linear congruential generator
uint lcg(inout uint prev)
{
    uint LCG_A = 1664525u;
    uint LCG_C = 1013904223u;
    prev = (LCG_A * prev + LCG_C);
    return prev & 0x00FFFFFF;
}

// Generate a random float in [0, 1) given the previous RNG state
float rando(inout uint prev)
{
    return (float(lcg(prev)) / float(0x01000000));
}
float reseed(inout uint seed) {
    float r = wang_hasher(seed) * (1.0 / 4294967296.0);
    seed += 2000;
    return r;
}

float InterleavedGradientNoise(float2 xy) {
    return frac(52.9829189f
        * frac(xy.x * 0.06711056f
            + xy.y * 0.00583715f));
}


float3 TraceForwardPaths(Ray r, PathTracingPayload p) {
    float3 totalColour = float3(0, 0, 0);
    float3 energy = float3(1, 1, 1);
    float3 origin = r.origin;
    float3 direction = r.direction;
    int jdff = 0;
    p.energy = energy;
    while(p.recursionDepth < MAX_RAY_RECURSION_DEPTH){
        //totalColour += p.colour;

        RayDesc ray;
        ray.Origin = origin;
        ray.Direction = direction;
        ray.TMin = 0.001;
        ray.TMax = 10000;

        p.weight = jdff;
        TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
            TraceRayParameters::InstanceMask,
            TraceRayParameters::HitGroup::Offset[RayType::Radiance],
            TraceRayParameters::HitGroup::GeometryStride,
            TraceRayParameters::MissShader::Offset[RayType::Radiance],
            ray, p);
        
        origin = p.pos;
        direction = p.dir;
        p.recursionDepth++;
    }
    return totalColour;
}


inline void VisualiseLightVertex(float4 photon, float4 colour, float4 w_i, float4 normal, float2 screenDims, float accumulatedFrames)
{
    // Get the Hit location of the photon
    float3 hitPosition = photon.xyz;
    uint brdf = (uint)photon.w;
    // Find the Screen Space Coord for the photon
    uint2 pixelPos;
    bool inRange;
    GetPixelPosition(hitPosition, screenDims, pixelPos, inRange);

    if (!inRange) {
        return;
    }

    // Shadow Ray.

    Ray r = { hitPosition, normalize(g_sceneCB.cameraPosition.xyz - hitPosition) };
    //ShadowRayPayload shadow = { true };
    bool shadow = ShadowRay(r, 0);

    /*TraceRay(g_scene,
        RAY_FLAG_CULL_BACK_FACING_TRIANGLES
        // ~skip any hit shaders
        | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Shadow],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Shadow],
        ray, shadow);*/

    if (!shadow || !g_sceneCB.renderFull) {
        float2 tempPixel = pixelPos;
        tempPixel /= screenDims;

        float3 delta = photon.xyz - g_sceneCB.cameraPosition.xyz;
        float invSqrLength = 1 / dot(delta, delta);
        float3 nDelta = delta * sqrt(invSqrLength);

        //evaluate BRDF given w_i, and -nDelta.
        float3 nEye = normalize(-delta);
        float cos_alpha = abs(dot(nEye, normal));
        //convert to radiance
        float lambertian = 0.0f;

        //we give all photons initial flux, so we don't need to normalize (essentially cancels out)
        //convert to radiance
        //*cos_alpha*inv
        float4 radiance = colour*cos_alpha* invSqrLength;

        if (brdf == 0) {
            lambertian = INV_PI * abs(dot(normalize(w_i), normal));
            float pdf = INV_PI * abs(dot(nEye, normal));
            radiance *= lambertian / pdf;
        }
        else {
           radiance = 0.0f;
        }


        /*uint3 scaledColor = radiance.xyz * 262144.f;
        uint3 newColorValue = float3(scaledColor);
        uint original;
        InterlockedAdd(stagingTarget_R[pixelPos], newColorValue[0], original);
        InterlockedAdd(stagingTarget_G[pixelPos], newColorValue[1], original);
        InterlockedAdd(stagingTarget_B[pixelPos], newColorValue[2], original);*/
        staging[pixelPos] += radiance;
       // AllMemoryBarrierWithGroupSync();
        // g_renderTarget[pixelPos] += radiance;//
        // lightTracingPhotons[8][pixelPos] += colour;
      //  InterlockedAdd(stagingTarget_R[pixelPos], 128, original);
       // InterlockedAdd(stagingTarget_G[pixelPos], 128, original);
        //InterlockedAdd(stagingTarget_B[pixelPos], 128, original);

         // else {
           //   g_renderTarget[pixelPos] = lerp(g_renderTarget[pixelPos], colour*conv, 1.0f / (accumulatedFrames + 1.0f));
          //}
    }


}


[shader("raygeneration")]
void ForwardPathTracingRayGen() {
    float2 samplePoint = DispatchRaysIndex().xy;
    uint spp = g_sceneCB.spp;

    float2 screenDims = DispatchRaysDimensions().xy;
  
   
    UINT currentRecursionDepth = 0;
    float3 radiance = 0.0f;
  

    uint accumulatedFrames = g_sceneCB.accumulatedFrames;
    //rng_state = uint(wang_hash_original(DispatchRaysIndex().x + DispatchRaysDimensions().x * DispatchRaysIndex().y  + 2000 * accumulatedFrames));
    for (int i = 0; i < 1; i++) {
        uint seed = uint(wang_hash_original(DispatchRaysIndex().x + DispatchRaysDimensions().x * DispatchRaysIndex().y  + accumulatedFrames*100000 ));

       // float2 rand = float2(rand_xorshift(), rand_xorshift());
        float2 screen_coord = DispatchRaysIndex().xy;
        //float3 r_4 = RandomUnitVector(ran);
        Ray r = GenerateCameraPath(screen_coord, g_sceneCB.cameraPosition.xyz, g_sceneCB.projectionToWorld);
        //float3 rando = float3(rand_xorshift(), rand_xorshift(), rand_xorshift());
        //set seed.
        PathTracingPayload payload = { float4(0,0,0,0), float3(1.0f, 1.0f, 1.0f), r.origin, r.direction, 1, 0,  0, seed };
    
        radiance +=  TraceForwardPath(r, payload).colour;
         //radiance = float3(0, 0, 0);
        //float3 otherrad = radiance * g_renderTarget[DispatchRaysIndex().xy].xyz;
        //radiance += otherrad;
       //g_renderTarget[DispatchRaysIndex().xy] = float4(rany, 0.0f, 1.0f);//float4(ri, r_2, r_3, 1.0f);

    }

    

   // float4 stagingColour = D
  //  radiance *= 1.0f / float(1);
 
   // float3 averageRadiance = stagingColour;
   float3 previousRadiance = accumulationLight[DispatchRaysIndex().xy].xyz;
    uint2 index = uint2(DispatchRaysIndex().xy);

   // float channel_r = stagingTarget_R[index];
    //float channel_g = stagingTarget_G[index];
    //float channel_b = stagingTarget_B[index];

    float4 lightStaging = staging[DispatchRaysIndex().xy];
  // float3 lightStaging = float3(channel_r, channel_g, channel_b) / (262144.f);
   float3 lightAverageRadiance;
   float w = accumulationLight[DispatchRaysIndex().xy].w;

    if (accumulatedFrames == 0) {
        lightAverageRadiance = lightStaging;
        w = 0;
    }
   
        
    else {
       // float blend = (iFrame < 2 || iMouse.z > 0.0 || lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));
       // 1.0f / (1.0f + (1.0f / lastFrameColor.a)
         if (lightStaging.x > 0 || lightStaging.y > 0 || lightStaging.z > 0) {
             w += 1;
         }
        lightAverageRadiance = lerp(previousRadiance.xyz, lightStaging.xyz, 1.0f / ((w) + 1.0f));
    }
    accumulationLight[DispatchRaysIndex().xy] = float4(lightAverageRadiance , w);
 
  /* if (accumulatedFrames == 0) {
         averageRadiance = stagingColour.xyz;
    }
    else {
      // float4 previousRadiance = g_renderTarget[DispatchRaysIndex().xy];
        averageRadiance = lerp(previousRadiance, stagingColour, 1.0f / (accumulatedFrames + 1.0f));
    }*/
    //linearly interpolate light map
   // accumulationLight[DispatchRaysIndex().xy] = float4(averageRadiance, 0);
    float3 forwardRadiance = radiance;
    if (accumulatedFrames == 0) {
       
    }
    else {
        float4 previousRadiance = accumulationForward[DispatchRaysIndex().xy];
        forwardRadiance = lerp(previousRadiance, forwardRadiance, 1.0f / (accumulatedFrames + 1.0f));

    }

    accumulationForward[DispatchRaysIndex().xy] = float4(forwardRadiance, 0);
    float3 totalRadiance;
    if (g_sceneCB.renderFull) {
        totalRadiance = forwardRadiance + lightAverageRadiance;
    }
    else {
        totalRadiance = lightAverageRadiance;
    }
    g_renderTarget[DispatchRaysIndex().xy] = float4((totalRadiance), 0);

    
   // averageRadiance = radiance;
   // averageRadiance = lerp(g_renderTarget[DispatchRaysIndex().xy], radiance, 1.0f / (accumulatedFrames + 1.0f));
   // g_renderTarget[DispatchRaysIndex().xy] = lightTracingPhotons[9][DispatchRaysIndex().xy];
    // g_renderTarget[DispatchRaysIndex().xy] = normalize(float4(accumulatedFrames, accumulatedFrames, accumulatedFrames, 0));
    //g_renderTarget[DispatchRaysIndex().xy] = float4(averageRadiance, 1.0f); //+ lightTracingPhotons[8][DispatchRaysIndex().xy];

}




uint labelBRDF() {
    if (l_materialCB.reflectanceCoef <= 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        return 0;
        //diffuse
    }
    else if (l_materialCB.reflectanceCoef >= 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        return 1;
        //reflective
    }
    else if (l_materialCB.refractiveCoef >= 0.0f) {
        return 2;
    }
    return 0;
}


float energy(float3 color)
{
    return dot(color, 1.0f / 3.0f);
}

float sdot(float3 x, float3 y, float f = 1.0f) {
    return saturate(dot(x, y) * f);
}

float3 phong_correct(float3 pos, float3 w_i, float3 normal, float alpha, inout float3 energy) {
    float3 ref = reflect(w_i, normal);
    
   // float specChance = energy(float3(1,1,1));
    float3 dir = SampleHemisphere(ref, alpha);
    float f = (alpha + 2) / (alpha + 1);
  //  float3 energy *= (1.0f / specChance) * float3(1,1,1) * sdot(normal, dir, f);
   // return (alpha + 2)/TWO_PI*(dot())
}

float SmoothnessToPhongAlpha(float s)
{
    return pow(1000.0f, s * s);
}




float3 directionFromBRDF(float3 normal, inout uint seed) {
    uint brdf = labelBRDF();
    float3 dir;
    if (brdf == 0) {
        //random direction


        //sample the light
        dir = cosWeightedRandomHemisphereDirection(normal, seed);
        // Ray r = { pos, dir };
    }
    else if (brdf == 1) {
        dir = reflect(WorldRayDirection(), normal);
        //reflected direction
    }
    else {
        //sample refraction
        float fresnel = Fresnel(WorldRayDirection(), normal, l_materialCB.refractiveCoef);
        bool outside = dot(dir, normal) < 0 ? false : true;
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, normal) > 0) {
            outwardNormal = -normal;
            index = n2;
        }
        else {
            outwardNormal = normal;
            index = n1 / n2;
        }
        refractTest(dir, outwardNormal, index, refracted);

        return refracted;
     

        //refracted direction
    }

    return dir;
}

float getWeightForPath(int e, int l) {
    return float(e + l + 2);
}

float3 connectP(float3 pos, uint recursionDepth, float3 forwardNormal, uint jdiff, float2 index) {
    float3 total = float3(0, 0, 0);
    for (int j = 0; j < MAX_RAY_RECURSION_DEPTH; j++) {
        uint c = j * 4;
        float4 lightPosition = lightTracingPhotons[c][index];
        float4 colour = lightTracingPhotons[c + 1][index];
        float4 normal = lightTracingPhotons[c + 2][index];
        float4 w_i = lightTracingPhotons[c + 3][index];

        float3 d = lightPosition.xyz - pos;
        float3 nD = normalize(d);
        Ray r = { pos.xyz, nD };
        bool isVisible = ShadowRay(r, recursionDepth);
        if (isVisible) {
            float weight = clamp(dot(nD, forwardNormal), 0.0, 1.0) * clamp(dot(-nD, normal), 0.0, 1.0) * clamp(1 / (dot(d, d)), 0.0f, 1.0f);
            total += weight * colour/getWeightForPath(jdiff, j);
        }
    }
    return total;
}
float3 connectPaths(float3 pos, uint recursionDepth, float3 forwardNormal, float3 brdfEval) {
   
    float3 total = 0.0f;
    for (int j = 0; j < MAX_RAY_RECURSION_DEPTH; j++) {
        uint c = j * 4;
        
        float4 lightPosition = lightTracingPhotons[c][DispatchRaysIndex().xy];
        float4 colour = lightTracingPhotons[c + 1][DispatchRaysIndex().xy];
        float4 normal = lightTracingPhotons[c + 2][DispatchRaysIndex().xy];
        float4 w_i = lightTracingPhotons[c + 3][DispatchRaysIndex().xy];


        float3 direct = lightPosition.xyz - pos;
        float invDistcSqr = 1.0f / dot(direct, direct);
        float3 n_direct = direct * invDistcSqr;
        Ray r = { pos.xyz, n_direct };
        float cosAtLight = max(dot(normal, n_direct), 0);
        float cosAtEyeVertex = max(dot(forwardNormal, n_direct), 0);

       
        
        bool isVisible = ShadowRay(r, recursionDepth);
        if (isVisible) {
            float3 d = lightPosition.xyz - pos.xyz;
            float invSqrLength = 1 / dot(d, d);
            float3 nDelta = d * sqrt(invSqrLength);
            float3 nE = normalize(-d);
            float3 cos_alpha = abs(dot(nE, normal));

            float3 radiance = colour * cos_alpha * invSqrLength;
            if (lightPosition.w == 0) {
                float lambertian = INV_PI * abs(dot(normalize(w_i), normal));
                float pdf = INV_PI * abs(dot(nE, normal));
                radiance *= pdf;
            }

            total += radiance;
           
        }

    }
    return total;
    
}

[shader("closesthit")]
void ForwardPathTracingClosestHitTriangle(inout PathTracingPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr) {

    float3 pos = HitWorldPosition();
    float3 normal = float3(0, 1, 0);
    float3 light_direction = (g_sceneCB.lightSphere.xyz - pos);

    //float3 flux = connectPaths(pos, rayPayload.recursionDepth, normal, 0);
   // uint brdfType = labelBRDF();
    //sample lights
    Ray sr = { pos , normalize(light_direction) };
    bool shadowHit = ShadowRay(sr, rayPayload.recursionDepth);
    float3 radiantFlux = 0.0f;



    if (rayPayload.recursionDepth >= 0) {
        uint seed = rayPayload.randomSeed;
        uint2 randIndex = float2(seed_xorshift(seed), seed_xorshift(seed));
        rayPayload.randomSeed = seed;
        randIndex.x *= DispatchRaysDimensions().x;
        randIndex.y *= DispatchRaysDimensions().y;
         radiantFlux = connectP(pos, rayPayload.recursionDepth, normal, rayPayload.weight, randIndex);
    }
    float s = chessSides(pos);
    float3 c = float3(0.8, 0.8, 0.8);
        //float3 c = float3(0.3, 0.3, 0.3);
    //float3 c = float3(1, 1, 1);
   // float3 c = float3(0.4, 0.4, 0.4);
    //float3 c = float3(0.1, 0.01, 0.3)*s;
    //lambertf is the light value here
    float3 lambert = lambertian(normal, pos, c);

    //radiantFlux //*= max(dot(-WorldRayDirection(), normal), 0);
    //brdf already multiplied by L_i
    //float3 dir =  calculateRandomDirectionInHemisphere(normal);
    //rayPayload.colour = float4(lambert.xyz, 0);
    float3 r_sample = float3(0, 0, 0);
    //sample the light
    uint seed = rayPayload.randomSeed;
   // float3 random = float3(seed_xorshift(seed), seed_xorshift(seed), seed_xorshift(seed));
    float3 dir = calculateRandomDirectionInHemisphereSeedShift(normal, seed);
   //float3 dir = SampleHemisphereSeedShift(normal, seed);
    rayPayload.randomSeed = seed;
    rayPayload.weight += 1;
   // rayPayload.randomSeed = seed;
    //float3 dir = normalize(normal + RandomUnitVector(seed));
    Ray r = { pos, dir };
    rayPayload.energy *= 2 * c * sdot(normal, dir);
    rayPayload.pdf = 0;
    r_sample = TraceForwardPath(r, rayPayload).colour;
    if (shadowHit) {
        lambert *= 0.7;
    }


    rayPayload.colour = float4(rayPayload.energy*r_sample + lambert + radiantFlux, 0);
    //rayPayload.colour +=float4(rayPayload.energy*lambert, 0);
    //sammple the hemisphere of the BRDF and connect it to the light
    //we have hit a triangle
    

    //want to connect this path to the light, evaluate radiance
    //L(x ,w ) = L_e(x, w) + L_dir(x, w) + L_indir(x, w)
   

}

[shader("closesthit")]

void ForwardPathTracingClosestHitProcedural(inout PathTracingPayload rayPayload, in ProceduralPrimitiveAttributes attr) {
    //want to connect this path to the light, evaluate radiance
    float3 pos = HitWorldPosition();
    float3 normal = attr.normal;
    uint brdf = labelBRDF();
    float4 reflectiveColour = float4(0, 0, 0, 0);
    float4 hitColour = float4(0, 0, 0, 0);
    float3 lambert = float3(0, 0, 0);
    float3 monte_sample = float3(0, 0, 0);
    float3 lightDir = g_sceneCB.lightSphere.xyz - pos;
    float3 radiantFlux = 0.0f;
    uint seed = rayPayload.randomSeed;
    float2 randIndex = float2(seed_xorshift(seed), seed_xorshift(seed));
   // randIndex.x *= DispatchRaysDimensions().x;
    //randIndex.y *= DispatchRaysDimensions().y;
    if (rayPayload.recursionDepth >= 0) {

        uint seed = rayPayload.randomSeed;
        float2 randIndex = float2(seed_xorshift(seed), seed_xorshift(seed));
        randIndex.x *= DispatchRaysDimensions().x;
        randIndex.y *= DispatchRaysDimensions().y;
        rayPayload.randomSeed = seed;
        radiantFlux = connectP(pos, rayPayload.recursionDepth, normal, rayPayload.weight, randIndex);
    }    //radiantFlux *= dot(-WorldRayDirection(), normal);

    Ray sr = { pos + 0.1 * attr.normal.xyz, normalize(lightDir) };
    bool shadowHit = ShadowRay(sr, rayPayload.recursionDepth);
   // float3 flux = connectPaths(pos, rayPayload.recursionDepth, normal, brdf);



    ///float s = chessBoard(pos);
    //float3 c = float3(0.3, 0.3, 0.3);
    //float3 c = float3(1, 1, 1);
    //float3 c = float3(0.1, 0.01, 0.3)*s;
    //lambertf is the light value here
    float s = chessSides(pos);
    float3 c = float3(l_materialCB.albedo.xyz);
   // lambert = lambertian(normal, pos, c);

    //uint seed = rayPayload.seed
    //float3 n_direction = SampleHemisphere()
    if (brdf == 0) {
        //sample light source
       // lambert = lambertian(normal, pos, l_materialCB.albedo);
        lambert = lambertian(normal, pos, c);

        uint seed = rayPayload.randomSeed;
        // float3 random = float3(seed_xorshift(seed), seed_xorshift(seed), seed_xorshift(seed));
        float3 dir = calculateRandomDirectionInHemisphereSeedShift(normal, seed);
        //float3 dir = SampleHemisphereSeedShift(normal, seed);
        rayPayload.randomSeed = seed;
        //setup random ray, and trace
        //uint seed = rayPayload.randomSeed;

        //sample the light
       // float3 dir = normalize(normal + RandomUnitVector(seed));
        Ray r = { pos, dir };
       // rayPayload.randomSeed = seed;
        rayPayload.pdf = 0;
        rayPayload.energy *= 2 * l_materialCB.albedo * sdot(normal, dir);
        monte_sample = TraceForwardPath(r, rayPayload).colour;
    }
    else if (brdf == 1) {
        rayPayload.weight = 0;
        uint seed = rayPayload.randomSeed;
        float roulette = seed_xorshift(seed);
        rayPayload.randomSeed = seed;
        rayPayload.pdf = 1;
        float doSpecular = (roulette < l_materialCB.specularCoef) ? 1.0f : 0.0f;
        seed = rayPayload.randomSeed;
        // float3 random = float3(seed_xorshift(seed), seed_xorshift(seed), seed_xorshift(seed));
        float3 dir = calculateRandomDirectionInHemisphereSeedShift(normal, seed);
        //float3 dir = SampleHemisphereSeedShift(normal, seed);
        rayPayload.randomSeed = seed;

        float3 specularDirection = reflect(WorldRayDirection(), attr.normal);
       
        specularDirection = normalize(lerp(specularDirection, dir, l_materialCB.diffuseCoef * l_materialCB.diffuseCoef));
        float3 lightDir = normalize(g_sceneCB.lightSphere.xyz - pos);
        float3 lightReflected = normalize(reflect(lightDir, attr.normal));
        float specHighlight = 0.0f;
        if (!shadowHit) {
            specHighlight = pow(max(dot(lightReflected, normalize(WorldRayDirection())), 0), 10000);

        }       
        
        rayPayload.energy *= l_materialCB.albedo;
        Ray r = { pos, specularDirection };
        reflectiveColour = TraceForwardPath(r, rayPayload).colour;
        reflectiveColour += specHighlight*6;

       
        
       /* float alpha = 300;
        float3 specular = 0.4f;
        float3 s = min(1.0f - specular, l_materialCB.albedo);
        float specChance = energy(specular);
        float diffChance = energy(s);

        float sum = specChance + diffChance;
        specChance /= sum;
        diffChance /= sum;
        uint seed = rayPayload.randomSeed;
        float roulette = seed_xorshift(seed);
        rayPayload.randomSeed = seed;
        if (roulette < specChance) {
            float3 direction = reflect(WorldRayDirection(), normal);
            rayPayload.energy *= (1.0f / specChance) * specular * sdot(normal, direction);

            Ray r = { pos, direction };
            reflectiveColour = TraceForwardPath(r, rayPayload).colour;
        }
        else {
            uint seed = rayPayload.randomSeed;
            float3 dir = SampleHemisphere(normal, seed);
            rayPayload.randomSeed = seed;
            rayPayload.energy *= (1.0f / diffChance) * s * sdot(normal, dir);
            Ray r = { pos, dir };
            reflectiveColour = TraceForwardPath(r, rayPayload).colour;
            reflectiveColour *= l_materialCB.albedo;
        }*/
     
    }else if(brdf == 2){
            float3 dir = WorldRayDirection();

            float4 refractColour;
            float4 reflectionColour;
            //sample refraction
            float fresnel = Fresnel(dir, attr.normal, l_materialCB.refractiveCoef);
            bool outside = dot(dir, attr.normal) < 0 ? false : true;
            float n1 = 1;
            float n2 = l_materialCB.refractiveCoef;
            float3 outwardNormal;
            float index;
            float3 refracted;
            if (dot(dir, attr.normal) > 0) {
                outwardNormal = -attr.normal;
                index = n2;
            }
            else {
                outwardNormal = attr.normal;
                index = n1 / n2;
            }
            refractTest(dir, outwardNormal, index, refracted);
            if (fresnel < 1) {

                Ray r = { pos, refracted };
                refractColour = TraceForwardPath(r, rayPayload).colour;
                //setup refracted ray

            }
            rayPayload.weight = 0;
            float3 reflected = normalize(reflect(dir, attr.normal));
            Ray r = { pos, reflected };
            float3 lightDir = normalize(g_sceneCB.lightSphere.xyz - pos);
            float3 lightReflected = normalize(reflect(lightDir, attr.normal));
            float specHighlight = 0.0f;
            if (!shadowHit) {
                specHighlight = pow(max(dot(lightReflected, normalize(WorldRayDirection())), 0), 10000);

            }
            reflectionColour = TraceForwardPath(r, rayPayload).colour;
            //reflectionColour += specHighlight;
            if (rayPayload.pdf == 1) {
                hitColour += reflectionColour * fresnel + refractColour * (1 - fresnel);
                hitColour *= l_materialCB.albedo + float4(specHighlight, specHighlight, specHighlight, 0) * 6;
            }
            //rayPayload.pdf = 1;

            //hitColour += l_materialCB.albedo;

    }
    if (shadowHit) {
       // hitColour.xyz *= 0.7;
        //reflectiveColour.xyz *= 0.7;
        //lambert *= 0.7;
    }
    
//float4(randIndex.xy, 0, 0);
    rayPayload.colour = float4(float4(rayPayload.energy, 0) * (hitColour.xyz + reflectiveColour.xyz + lambert + radiantFlux + monte_sample), 0);
 
}

[shader("miss")]

void MissPathTracing(inout PathTracingPayload rayPayload) {
    float3 ndir = normalize(WorldRayDirection());
    rayPayload.energy = 0.0f; 
    //rayPayload.colour = float4(0.1f, 0.1f, 0.1f, 0);
   // rayPayload.colour = float4(0.3f, 0.3f, 0.3f, 0);

   // rayPayload.colour = float4(0.4f, 0.4f, 0.4f, 0);
    rayPayload.colour = float4(0.6f , 0.6f, 0.6f, 0);
    //rayPayload.colour = float4(0.2f, 0.2f, 0.2f, 0);
    //rayPayload.colour = BackgroundColor;
   // rayPayload.colour = float4(getColour(ndir), 0);
    rayPayload.recursionDepth = MAX_RAY_RECURSION_DEPTH;

}





void lightPath(inout float seed) {
   
    // float2 r = rand_xor(ran);
    //float2 rany = float2(rand_ik(seed), rand_ik(seed));
    float2 randomSample = float2(seed_xorshift(seed), seed_xorshift(seed));
    // randomSample = float2(rand_xorshift(), rand_xorshift());
    float2 random = float2(rand_xorshift(), rand_xorshift());
    float3 dir = SquareToSphereUniform(random);
  //  float3 ro = randomSphereDirection(seed);
   // float3 rd = cosWeightedRandomHemisphereDirection(ro, seed);
   float3  ro = g_sceneCB.lightSphere.xyz;
   // ro = g_sceneCB.lightSphere.xyz + ro * g_sceneCB.lightSphere.w;
   // float3 origin = g_sceneCB.lightPosition;
   // float3 dir = normalize(SquareToSphereUniform(rany));
   uint count = 0;
    PathTracingPayload p = { 75*g_sceneCB.lightDiffuseColor, float3(0,0,0), ro, dir, 1, 0, 0, seed };
   while(p.recursionDepth <= MAX_RAY_RECURSION_DEPTH){
        float3 normal;
        //ntersect scene
        RayDesc rayDesc;
        rayDesc.Origin = ro;
        rayDesc.Direction = dir;
        rayDesc.TMin = 0.001;
        rayDesc.TMax = 1000000;

        TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
            TraceRayParameters::InstanceMask,
            TraceRayParameters::HitGroup::Offset[RayType::Radiance],
            TraceRayParameters::HitGroup::GeometryStride,
            TraceRayParameters::MissShader::Offset[RayType::Radiance],
            rayDesc, p);

  
        //lightTracingPhotons[1][g_index] = float4(p.dir, 0);
        //lightTracingPhotons[2][g_index] = float4(p.colour);

        //lightTracingPhotons[p.recursionDepth + 1][DispatchRaysIndex().xy] = float4(p.pos, 0);
     
            p.recursionDepth++;
        
        ro = p.pos;
        dir = p.dir;
    }
}





[shader("raygeneration")]
void LightTracingRayGen() {
    staging[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
   // uint2 index = DispatchRaysIndex().xy;
  //  stagingTarget_R[index] = 0;
    //stagingTarget_G[index] = 0;
    //stagingTarget_B[index] = 0;
    float2 screenDims = float2(DispatchRaysDimensions().x, DispatchRaysDimensions().y); 
   
    for (int j = 0; j < 4*MAX_RAY_RECURSION_DEPTH; j++) {
        
        lightTracingPhotons[j][DispatchRaysIndex().xy] = 0.0f;
    }
    uint accumulatedFrames = g_sceneCB.accumulatedFrames;

        rng_state = uint(wang_hash_original(DispatchRaysIndex().x + DispatchRaysDimensions().x * DispatchRaysIndex().y) +  accumulatedFrames*100000);
        uint seed = uint(wang_hash_original(DispatchRaysIndex().x + DispatchRaysDimensions().x * DispatchRaysIndex().y + accumulatedFrames * 100000));

        //seed = DispatchRaysIndex().x + DispatchRaysIndex().y * 3.43121412313 + frac(1.12345314312 * accumulatedFrames)*g_sceneCB.rand1;
        lightPath(seed);

      //  float3 totalRadiance = 0.0f;
      
       // g_renderTarget[DispatchRaysIndex().xy] = float4(rand_xorshift(), rand_xorshift(), rand_xorshift(), rand_xorshift());

   


    //float3 ro = randomSphereDirection(seed);
    //float3 rd = cosWeightedRandomHemisphereDirection(ro, seed);
    //g_renderTarget[DispatchRaysIndex().xy] = float4(rds, 0);

    
    //create random sample on hemisphere
    //then trace

}


[shader("raygeneration")]
void lightTracingRayGenSecondPass() {


    uint accumulatedFrames = g_sceneCB.accumulatedFrames;
    uint2 screenDims = DispatchRaysDimensions().xy;
    for (int j = 0; j < MAX_RAY_RECURSION_DEPTH; j++) {
        uint c = j * 4;
        float4 pos = lightTracingPhotons[c][DispatchRaysIndex().xy];
        float4 colour = lightTracingPhotons[c + 1][DispatchRaysIndex().xy];
        float4 normal = lightTracingPhotons[c + 2][DispatchRaysIndex().xy];
        float4 dir = lightTracingPhotons[c + 3][DispatchRaysIndex().xy];

        // g_renderTarget[DispatchRaysIndex().xy] += float4(pos);
        VisualiseLightVertex(pos, colour, dir, normal, screenDims, g_sceneCB.accumulatedFrames);

        //g_renderTarget[DispatchRaysIndex().xy] = float4(1, 1, 0, 0);
    }
}

[shader("closesthit")]
void lightTracingClosestHitSecondPass(inout PathTracingPayload payload, in BuiltInTriangleIntersectionAttributes attr) {
    return;
}

[shader("miss")]
void lightTracingSecondPassMiss(inout PathTracingPayload payload) {
    return;
}

//SORT_FORCEINLINE float CosHemispherePdf(const Vector& v) {
  //  return absCosTheta(v) * INV_PI;
//}

[shader("closesthit")]
void LightTracingClosestHitTriangle(inout PathTracingPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr) {
    float3 normal = float3(0, 1, 0);
    float3 pos = HitWorldPosition();

    uint2 index = DispatchRaysIndex().xy;
    float4 colour = rayPayload.colour;
    uint brdfType = labelBRDF();

    uint c = (rayPayload.recursionDepth - 1) * 4;
    colour *= float4(0.8, 0.8, 0.8, 0);
    if (rayPayload.recursionDepth >= 1) {
        lightTracingPhotons[c][index] = float4(pos, float(brdfType));
        lightTracingPhotons[c + 1][index] = colour;
        lightTracingPhotons[c + 2][index] = float4(normal, 0);
        lightTracingPhotons[c + 3][index] = float4(-WorldRayDirection(), 0);
    }
   // colour /= lambertPdf;
   
        float lambertPdf = abs(dot(-WorldRayDirection(), normal)) * INV_PI;
       
        uint seed = rayPayload.randomSeed;
        float2 randomSample = float2(seed_xorshift(seed), seed_xorshift(seed));
       // randomSample = float2(rand_xorshift(), rand_xorshift());
        rayPayload.randomSeed = seed;

        //uint seed = rayPayload.randomSeed;
        float3 dir = SquareToHemisphereCosine(randomSample);
       // colour *= INV_PI;
        //colour *= abs(dot(normal, dir)) / abs(dot(normal, -WorldRayDirection())) * INV_PI;
 
        Ray r = { pos, dir };
        //float3 dir = normalize(normal + RandomUnitVector(seed));
        // Ray r = { pos, dir };
        //float3 r = cosWeightedRandomHemisphereDirection(normal, seed);

      
        rayPayload.dir = dir;
        rayPayload.pos = pos;
        rayPayload.colour = colour;
}


[shader("closesthit")]
void LightTracingClosestHitProcedural(inout PathTracingPayload rayPayload, in ProceduralPrimitiveAttributes attr) {
    float3 normal = attr.normal;
    float3 pos = HitWorldPosition().xyz;
    float3 dir = normalize(WorldRayDirection());
    //uint c = 4 * rayPayload.recursionDepth;
    uint c = (rayPayload.recursionDepth - 1) * 4;
    float4 colour = rayPayload.colour;
    uint brdfType = labelBRDF();
    uint2 index = DispatchRaysIndex().xy;
    colour *=  l_materialCB.albedo;

    if (rayPayload.recursionDepth >= 1) {
        lightTracingPhotons[c][index] = float4(pos, float(brdfType));
        lightTracingPhotons[c + 1][index] = colour;
        lightTracingPhotons[c + 2][index] = float4(normal, 0);
        lightTracingPhotons[c + 3][index] = float4(-WorldRayDirection(), 0);
    }

    if (l_materialCB.reflectanceCoef == 0.0f && l_materialCB.refractiveCoef == 0.0f) {
       
        uint seed = rayPayload.randomSeed;
        float2 randomSample = float2(seed_xorshift(seed), seed_xorshift(seed));
        rayPayload.randomSeed = seed;
        //uint seed = rayPayload.randomSeed;
        float3 dir = SquareToHemisphereCosine(randomSample);
        // float3 dir = normalize(normal + RandomUnitVector(seed));
         // Ray r = { pos, dir };
        // float3 r = cosWeightedRandomHemisphereDirection(normal, seed);



        colour *= INV_PI;
        colour *= abs(dot(attr.normal, dir)) / abs(dot(attr.normal, -WorldRayDirection())) * INV_PI;
        //lambertian brdf
        rayPayload.dir = dir;
        rayPayload.pos = pos;
        rayPayload.colour = colour;
    }
    if (l_materialCB.reflectanceCoef > 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        uint seed = rayPayload.randomSeed;
        float roulette = seed_xorshift(seed);
        //rayPayload.randomSeed = seed;
        float doSpecular = (roulette < l_materialCB.specularCoef) ? 1.0f : 0.0f;
        float d = calculateRandomDirectionInHemisphereSeedShift(normal, seed);
        rayPayload.randomSeed = seed;

       

        float3 specularDirection = reflect(WorldRayDirection(), attr.normal);
        specularDirection = normalize(lerp(specularDirection, dir, l_materialCB.diffuseCoef * l_materialCB.diffuseCoef));
        rayPayload.colour = colour;
        rayPayload.pos = pos;
        rayPayload.dir = specularDirection;

        
    }
    else if (l_materialCB.refractiveCoef > 0.0f) {
        //float3 d;
        float fresnel = Fresnel(dir, attr.normal, l_materialCB.refractiveCoef);
        bool outside = dot(dir, attr.normal) < 0 ? false : true;
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, attr.normal) > 0) {
            outwardNormal = -attr.normal;
            index = n2;
        }
        else {
            outwardNormal = attr.normal;
            index = n1 / n2;
        }
        refractTest(dir, outwardNormal, index, refracted);
       // rayPayload.randomSeed = seed;
        uint seed = rayPayload.randomSeed;
        float roulette = seed_xorshift(seed);
        rayPayload.randomSeed = seed;
        if (fresnel < 1) {

           // Ray r = { pos, refracted };
            //float temp = payload.probability;
           // payload.probability = (1 - fresnel);

            rayPayload.pos = pos;
            rayPayload.dir = refracted;
            rayPayload.colour = colour;
            //setup refracted ray

        }
        else {

            float3 reflected = (reflect(dir, attr.normal));
           // Ray r = { pos, reflected };
            //payload.probability = (fresnel);
            rayPayload.pos = pos;
            rayPayload.dir = reflected;
            rayPayload.colour = colour;
            //refractPos = TracePhotonRay(r, payload).position;
        }


    }


}




//***************************************************************************
//********************------ Ray gen shader.. -------************************
//***************************************************************************
[shader("raygeneration")]
void MyRaygenShader()
{    
    g_renderTarget[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);

   // g_rasterTarget[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);

   // photonBufferCounter.Store(0, 0);

    //photonBuffer.DecrementCounter();
    float2 samplePoint = DispatchRaysIndex().xy;

    uint width;
    uint height;
    g_renderTarget.GetDimensions(width, height);
    float2 screenDims = float2(width, height);

    GBufferBRDF[DispatchRaysIndex().xy] = float4(0,0,0, 0);
    GBufferPosition[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
    GBufferNormal[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);


    /*  for (int i = 0; i < 100; i++) {
        Photon p = photonBuffer[i + DispatchRaysIndex().x + i*DispatchRaysIndex().y];
        VisualizePhoton(p.position, p.colour, screenDims);
    }*/

  /*  for (int i = 0; i < 6; i++) {
        float4 photon = screenSpacePhoton[i][samplePoint];
        float4 colour = screenSpacePhotonColour[i][samplePoint];
        VisualizePhoton(photon, colour, screenDims);
    }*/
       
   // VisualizePhotonBuffer( screenDims);

    rng_state = uint(wang_hash_original(samplePoint.x + DispatchRaysDimensions().x * samplePoint.y));

    UINT currentRecursionDepth = 0;
  Ray r = GenerateCameraRay(DispatchRaysIndex().xy, g_sceneCB.cameraPosition.xyz, g_sceneCB.projectionToWorld);
 //   Ray r = { ray.Origin, ray.Direction };
    RayPayload payload = { float4(0,0,0,0), 
        0,
        0 };
    //RayPayload traced = TraceRadianceRay(ray, payload);
    RayPayload traced = TraceRadianceRay(r, payload);

    // Write the raytraced color to the output texture.
    g_renderTarget[DispatchRaysIndex().xy] =  traced.color; //+ screenSpacePhotonMap[0][samplePoint];
    //uint offset = 0;

    //if drawing rays,   need to write the intersections for this ray into a 3D tensor.

}



//***************************************************************************
//******************------ Closest hit shaders -------***********************
//***************************************************************************

//implement a BRDF microfacet for the ground
[shader("closesthit")]
void MyClosestHitShader_Triangle(inout RayPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr)
{
    uint indexSizeInBytes = 4;
    uint indicesPerTriangle = 3;
    uint triangleIndexStride = indicesPerTriangle * indexSizeInBytes;
    uint baseIndex = PrimitiveIndex() * triangleIndexStride;

    // Load up three 16 bit indices for the triangle.
    const uint3 indices = Load3x16BitIndices(baseIndex, g_indices);

    // Retrieve corresponding vertex normals for the triangle vertices.
    float3 triangleNormals[3] = { g_vertices[indices[0]].normal,
                                   g_vertices[indices[1]].normal,
                                    g_vertices[indices[2]].normal
    };

    float3 triangleNormal = HitAttribute(triangleNormals, attr.barycentrics);
    float4 ambient = l_materialCB.albedo;
    float3 hitPos = HitWorldPosition();
    float3 pos = HitWorldPosition();
    float3 dir = normalize(g_sceneCB.lightSphere.xyz - pos);
    float3 r_dir = randomDirection(HitWorldPosition().xy);
    float3 l_dir = g_sceneCB.lightSphere.xyz - hitPos;
    float3 pos_n =normalize(HitWorldPosition());

    uint depth = rayPayload.recursionDepth;

   
    float c = chessSides(pos);

    Ray shadowRay;
    shadowRay.origin = HitWorldPosition();
    shadowRay.direction = dir;
    bool shadowHit = ShadowRay(shadowRay, rayPayload.recursionDepth);
    float3 normal = float3(0, 1, 0);
    float4 reflectionColour = float4(0, 0, 0, 0);
    
    float3 diffuseColour = float4(0.8, 0.8, 0.8, 0);

   
        //if immediate ray - i.e., recursion depth = 1
    if (rayPayload.recursionDepth == 1) {
        //store normal, and other elements in relevant GBuffer

        //for some reason the triangle normal is not working??! - for now just suppose n = (0, -1, 0)
        GBufferBRDF[DispatchRaysIndex().xy] = float4(diffuseColour, 1);
        GBufferPosition[DispatchRaysIndex().xy] = float4(pos, 0);
        GBufferNormal[DispatchRaysIndex().xy] = float4(0, 1, 0, 0);
    }

    if (shadowHit) {
        diffuseColour *= 0.5;
    }
   diffuseColour *= orenNayar(normalize(WorldRayDirection()), normal, normalize(l_dir), 1);
    



    
      if(l_materialCB.reflectanceCoef > 0){
        Ray r = { HitWorldPosition(), reflect(WorldRayDirection(), triangleNormal) };
        reflectionColour = TraceRadianceRay(r, rayPayload).color;

    }

    float4 color =  float4(diffuseColour.xyz, 0) + 0.15*reflectionColour;
    float t = RayTCurrent();
  //color = lerp(color, BackgroundColor, 1.0 - exp(-0.000002 * t * t * t));
    float3 colour;

    //rayPayload.color = color;
   // rayPayload.color = float4(colour, 0);
    float4 backColour = float4(getColour(normalize(WorldRayDirection())), 1);
    rayPayload.color = color;
    //rayPayload.color =  lerp(color, backColour, 1.0 - exp(-0.000002 * t * t * t)) + float4(colour, 0);

   // rayPayload.intersections[rayPayload.recursionDepth] = color;


}

//implement fresnel




[shader("closesthit")]
void MyClosestHitShader_AABB(inout RayPayload rayPayload, in ProceduralPrimitiveAttributes attr)
{

    float3 pos = HitWorldPosition();
    float3 pos_n = normalize(HitWorldPosition());

    //intersectionBuffer[rayPayload.recursionDepth][DispatchRaysIndex().xy] = normalize(float4(pos, 1));

    //g_buffer[1080*y + x] = float4(pos, 1);
    float3 l_dir = normalize(g_sceneCB.lightSphere.xyz - pos);
    float4 reflectionColour = float4(0, 0, 0, 1);
    Ray shadowRay = { pos + 0.1 * attr.normal.xyz, l_dir };
    float3 currentDir = RayTCurrent() * WorldRayDirection();
    currentDir += WorldRayOrigin();
    //Ray sr = { pos + 0.1 * attr.normal.xyz, normalize(lightDir) };

    bool shadowHit = ShadowRay(shadowRay, rayPayload.recursionDepth);


    if (rayPayload.recursionDepth == 1) {
        //store normal, and other elements in relevant GBuffer
        float3 l = lambertian(attr.normal, pos, l_materialCB.albedo);
        GBufferBRDF[DispatchRaysIndex().xy] = float4(l, 0);
        GBufferPosition[DispatchRaysIndex().xy] = float4(pos, 0);
        GBufferNormal[DispatchRaysIndex().xy] = float4(attr.normal, 0);
    }
    bool diffuse = false;
    float3 hitColour = float3(0, 0, 0);
    if (!shadowHit) {
        //ambient += 0.1*PhongLighting(float4(attr.normal, 0), shadowHit);
    }
    float3 dir = normalize(WorldRayDirection());
    float4 refractColour = float4(0, 0, 0, 0);
    if (l_materialCB.reflectanceCoef > 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        Ray r = { pos, reflect(dir, attr.normal) };
        reflectionColour = TraceRadianceRay(r, rayPayload).color;
        hitColour += reflectionColour;

     


    }
    else if (l_materialCB.refractiveCoef > 0.0f) {
        float fresnel = Fresnel(dir, attr.normal, l_materialCB.refractiveCoef);
        bool outside = dot(dir, attr.normal) < 0 ? false : true;
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, attr.normal) > 0) {
            outwardNormal = -attr.normal;
            index = n2;
        }
        else {
            outwardNormal = attr.normal;
            index = n1 / n2;
        }
        refractTest(dir, outwardNormal, index, refracted);
        if (fresnel < 1) {

            Ray r = { pos, refracted };
            refractColour = TraceRadianceRay(r, rayPayload).color;
            //setup refracted ray

        }

        float3 reflected = normalize(reflect(dir, attr.normal));
        Ray r = { pos, reflected };
        reflectionColour = TraceRadianceRay(r, rayPayload).color;
        // hitColour = refractColour;
        hitColour += (reflectionColour * fresnel + refractColour * (1 - fresnel));
    }
    else {
        diffuse = true;
        hitColour += lambertian(attr.normal, pos, l_materialCB.albedo);//orenNayar(normalize(WorldRayDirection()), attr.normal, normalize(l_dir), 1);
       // hitColour =   lambertian(attr.normal, pos, l_materialCB.albedo);
        if (shadowHit) {
            hitColour *= 0.5;
        }
    }
    float re = reflectionBRDF(dir, attr.normal);

    //0.1f is a good coefficient for reflectioncolour.
     // rayPayload.color += refractionColour + 0.1*reflectionColour;
    //  rayPayload.color = refractionColour;
    float4 colour;
    if (!diffuse) {
        float3 lightDir = normalize(g_sceneCB.lightSphere.xyz - pos);
        float3 lightReflected = normalize(reflect(lightDir, attr.normal));
        float specHighlight = 0.0f;
        if (!shadowHit) {
            specHighlight = pow(max(dot(lightReflected, normalize(WorldRayDirection())), 0), 10000);

        }

        hitColour += specHighlight*6;
        colour = float4(l_materialCB.albedo * hitColour.xyz, 0);
    }
    else {
        colour = float4(hitColour.xyz + l_materialCB.albedo, 0);
    }

//ray
//float3 sky = lerp(float3(0.52, 0.77, 1), float3(0.12, 0.43, 1), BackgroundColor.xyz);

float t = RayTCurrent();
float4 backColour = float4(getColour(normalize(WorldRayDirection())), 1);
//rayPayload.color = lerp(colour, backColour, 1.0 - exp(-0.000002 * t * t * t));
rayPayload.color = colour;

}

//***************************************************************************
//**********************------ Miss shaders -------**************************
//***************************************************************************



[shader("miss")]
void MyMissShader(inout RayPayload rayPayload)
{
   // float transition = pow(smoothstep(0.02, .5, d.y), 0.4);
//
    float3 ndir = normalize(WorldRayDirection());
    rayPayload.color += float4(0.6f, 0.6f, 0.6f, 0);
    //rayPayload.color += float4(0.7, 0.7, 0.7, 0);
  //  rayPayload.color += BackgroundColor;
//   rayPayload.color += float4(getColour(ndir), 1);
   // float4 backgroundColor = float4(BackgroundColor);
    uint depth = rayPayload.recursionDepth;
    //float3 sky = lerp(float3(0.52, 0.77, 1), float3(0.12, 0.43, 1), BackgroundColor);
  //  rayPayload.color = BackgroundColor;
    //rayPayload.color =  float4(lerp(SkyColour.xyz, float3(0.4, 0.4, 0.4), float4(BackgroundColor)), 1);
    //g_renderTarget[DispatchRaysIndex().xy] = rayPayload.color;
   // intersectionBuffer[depth][DispatchRaysIndex().xy] = float4(0,0,0,0);

}

[shader("miss")]
void MyMissShader_ShadowRay(inout ShadowRayPayload rayPayload)
{


    rayPayload.hit = false;
}


//***************************************************************************
//**********************------ Any Hit Shaders -------**************************
//***************************************************************************
[shader("anyhit")]
void AnyHit_AnalyticPrimitive(inout RayPayload payload, in ProceduralPrimitiveAttributes attr) {
    //IgnoreHit();
    float3 pos = HitWorldPosition();
    if (l_materialCB.refractiveCoef > 0) {
        //  if(ShadowRay(payload)){}
         // payload.color = float4(1, 1, 0, 1);
         //IgnoreHit();
    }
    // payload.color = float4(1, 1, 0, 1);
}

[shader("anyhit")]
void AnyHit_Triangle(inout RayPayload payload, in BuiltInTriangleIntersectionAttributes attr) {
    // payload.color = float4(0, 0, 0, 1);
    //IgnoreHit();
}
//***************************************************************************
//*****************------ Intersection shaders-------************************
//***************************************************************************


[shader("closesthit")]
void ClosestHit_CSG( inout RayPayload payload, in ProceduralPrimitiveAttributes attr){

}
// Get ray in AABB's local space.
Ray GetRayInAABBPrimitiveLocalSpace()
{
    PrimitiveInstancePerFrameBuffer attr = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];

    // Retrieve a ray origin position and direction in bottom level AS space 
    // and transform them into the AABB primitive's local space.
    Ray ray;
    ray.origin = mul(float4(ObjectRayOrigin(), 1), attr.bottomLevelASToLocalSpace).xyz;
    ray.direction = mul(ObjectRayDirection(), (float3x3) attr.bottomLevelASToLocalSpace);
    return ray;
}

[shader("intersection")]
void MyIntersectionShader_AnalyticPrimitive()
{
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
    AnalyticPrimitive::Enum primitiveType = (AnalyticPrimitive::Enum) l_aabbCB.primitiveType;
   // AnalyticPrimitive::Enum primitiveType = AnalyticPrimitive::Enum::Plane;
    float thit;
    ProceduralPrimitiveAttributes attr;
    if (RayAnalyticGeometryIntersectionTest(localRay, primitiveType, thit, attr))
    {
        PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit, /*hitKind*/ 0, attr);
    }
}

[shader("intersection")]
void MyIntersectionShader_VolumetricPrimitive()
{
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
    VolumetricPrimitive::Enum primitiveType = (VolumetricPrimitive::Enum) l_aabbCB.primitiveType;
    
    float thit;
    ProceduralPrimitiveAttributes attr;
  
  /*  if (RayVolumetricGeometryIntersectionTest(localRay, primitiveType, thit, attr, 0))
    {
        PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit, /*hitKind*/ //0, attr);
   // }
}

[shader("intersection")]
void MyIntersectionShader_SignedDistancePrimitive()
{
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
    SignedDistancePrimitive::Enum primitiveType = (SignedDistancePrimitive::Enum) l_aabbCB.primitiveType;

    float thit;
    ProceduralPrimitiveAttributes attr;

    /*if (RaySignedDistanceQuatTest(localRay, thit, attr)) {
        PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit, 0, attr);
    }*/
    if (RaySignedDistanceTest(localRay, primitiveType, thit, attr, g_sceneCB.elapsedTime, l_materialCB.stepScale))
    {
        PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit,  0, attr);
    }
 
}



bool isEmpty(CSGNode csgStack[15], int nodePointer) {
    if (nodePointer <= -1) {
        return true;
    }
    return false;
}


void Push(inout CSGNode csgStack[15], inout int nodePointer, CSGNode node) {
    nodePointer += 1;
    csgStack[nodePointer] = node;
}

CSGNode Pop(inout CSGNode csgStack[15], inout int nodePointer) {
    CSGNode popped = csgStack[nodePointer];
    nodePointer -= 1;
    return popped;
}


void CSGCombine(in int operation, in intersectionInterval left, in intersectionInterval right, inout float tmin, inout float tmax, inout float3 normal, inout bool hit) {
  
    if (operation == 0) {
        if (left.hit && right.hit) {
            //union
            //get smallest and largest values over all intersections -- will need to record whether there were intersections for the subtrees
            tmin = min(left.tmin, right.tmin);
            tmax = max(left.tmax, right.tmax);
            if (tmin == left.tmin) {
                normal = left.normal;
            }
            else {
                normal = right.normal;
            }
            hit = true;
        }
        //else we don't intersect one of the subtrees
        else {
            if (right.hit) {
                tmin = right.tmin;
                tmax = right.tmax;
                normal = right.normal;
                hit = true;
            }
            else if(left.hit){
                tmin = left.tmin;
                tmax = left.tmax;
                normal = left.normal;
                hit = true;
            }
            else {
                tmin = -1;
                tmax = -1;
                normal = float3(0, 0, 0);
                hit = false;
            }
        }
    }




    else if (operation == 1) {
        //intersection
        if (left.hit && right.hit) {
            float e = max(left.tmin, right.tmin);
            float f = min(left.tmax, right.tmax);
            hit = true;
            tmin = min(e, f);
            tmax = max(e, f);

            if (tmin == e) {
                if (e == left.tmin) {
                    normal = left.normal;
                }
                else {
                    normal = right.normal;
                }
            }
        }
        else {
            tmin = -1;
            tmax = -1;
            normal = float3(0, 0, 0);
            hit = false;
        }
    }





    else {

    //difference
        if (right.hit && left.hit) {
            if (right.tmin < left.tmin) {
                tmin = right.tmin;
                tmax = left.tmin;
                normal = right.normal;
                hit = true;

            }
            else if (left.tmax < right.tmax) {
                tmin = left.tmax;
                tmax = right.tmax;
                normal = -left.normal;
                hit = true;

            }
            else {
                tmin = -1;
                tmax = -1;
                normal = float3(0, 0, 0);
                hit = false;
                
            }
        }
        else {
            if (right.hit) {
                tmin = right.tmin;
                tmax = right.tmax;
                normal = right.normal;
                hit = true;
            }
            else {
                tmin = -1;
                tmax = -1;
                normal = float3(0, 0, 0);
                hit = false;
            }
        }
    }

    
}
Classify::Enum classifyIntersectionCSGIntersection(classificationInterval left, classificationInterval right) {
    //entry is based on 
    switch (left.classification) {
    case 0:
        if (right.classification == 0) {
            //enter both.
            //return minimum value
            if (left.tmin < right.tmin) {
                return Classify::Enum::AdvanceLeftLoop;
            }
            else {
                return Classify::Enum::AdvanceRightLoop;
            }
        }
        else if (right.classification == 1) {
            if (left.tmin < right.tmin) {
                return Classify::Enum::Left;
            }
            else {
                return Classify::Enum::AdvanceRightLoop;//Classify::Enum::Left;
                //return Classify::Enum::AdvanceLeftLoop;
            }
        }
        else if (right.classification == -1) {
            return Classify::Enum::Miss;
        }
        break;
    case 1:
        if (right.classification == 0) {
            if (right.tmin < left.tmin) {
                return Classify::Enum::Right;
            }
            else {
                return Classify::Enum::AdvanceLeftLoop;//Classify::Enum::Right;
                // return Classify::Enum::AdvanceRightLoop;
            }
        }
        else if (right.classification == 1) {
            if (left.tmin < right.tmin) {
                return Classify::Enum::Left;
            }
            else {
                return Classify::Enum::Right;
            }
        }
        else if (right.classification == -1) {
            return Classify::Enum::Miss;
        }
        break;
    case -1:
        if (right.classification == 0 || right.classification == 1 || right.classification == -1) {
            return Classify::Enum::Miss;
        }
     
        break;
    }
    return Classify::Enum::Miss;

}

Classify::Enum classifyDifference(classificationInterval left, classificationInterval right) {
    //entry is based on 
    switch (left.classification) {
    case 0:
        if (right.classification == 0) {
            //enter both.
            //return minimum value
            if (left.tmin < right.tmin) {
                return Classify::Enum::Left;
            }
            else {
                return Classify::Enum::AdvanceRightLoop;
            }
        }
        else if (right.classification == 1) {
            if (right.tmin < left.tmin) {
                return Classify::Enum::AdvanceRightLoop;
            }
            else {
                return Classify::Enum::AdvanceLeftLoop;
            }
        }
        else if (right.classification == -1) {
            return Classify::Enum::Left;
        }
        break;
    case 1:
        if (right.classification == 0) {
            if (left.tmin < right.tmin) {
                return Classify::Enum::Left;
            }
            else {
                return Classify::Enum::RightWithNormFlip;
            }
            //also need to flip norm
        }

        else if (right.classification == 1) {
            if (right.tmin < left.tmin) {
                return Classify::Enum::RightWithNormFlip;
            }
            else {
                return Classify::Enum::AdvanceLeftLoop;
            }
        }
        else if (right.classification == -1) {
            return Classify::Enum::Left;
        }
        break;
    case -1:
        return Classify::Enum::Miss;
        break;
    }
    return Classify::Enum::Miss;

}
Classify::Enum classifyIntersectionCSG(classificationInterval left, classificationInterval right) {
    //entry is based on 
    switch (left.classification) {
    case 0:
        if (right.classification == 0) {
            //enter both.
            //return minimum value
            if (left.tmin < right.tmin) {
                return Classify::Enum::Left;
            }
            else {
                return Classify::Enum::Right;
            }
        }
        else if (right.classification == 1) {
            if (right.tmin < left.tmin) {
                return Classify::Enum::Right;
            }
            else {
                return Classify::Enum::AdvanceLeftLoop;
            }
        }
        else if (right.classification == -1) {
            return Classify::Enum::Left;
        }
        break;
    case 1:
        if (right.classification == 0) {
            if (left.tmin < right.tmin) {
                return Classify::Enum::Left;
            }
            else {
                return Classify::Enum::AdvanceRightLoop;
            }
        }
        else if (right.classification == 1) {
            if (left.tmin > right.tmin) {
                return Classify::Enum::AdvanceRightLoop;
                //return Classify::Enum::Left;
            }
            else {
                return Classify::Enum::AdvanceLeftLoop;
                //return Classify::Enum::Right;
            }
        }
        else if (right.classification == -1) {
            return Classify::Enum::Left;
        }
        break;
    case -1:
        if (right.classification == 0 || right.classification == 1) {
            return Classify::Enum::Right;
        }
        else if (right.classification == -1) {
            return Classify::Enum::Miss;
        }
        break;
    }
    return Classify::Enum::Miss;
    
}
/*else {
          //we have a node;
          classificationInterval left = intersections[i - 2 * depth];
          classificationInterval right = intersections[i - 1];
          //want to classify the hits b
          bool continueLoop = true;
          //an action
          classificationInterval inter = { -1, -1, false, float3(0,0,0) };

          while (continueLoop) {
              Classify::Enum action = classifyIntersectionCSG(left, right);

              if (action == Classify::Enum::Miss) {
                  //miss
                  continueLoop = false;
                  //return miss
              }
              else if (action == Classify::Enum::Left || action == Classify::Enum::LeftIfCloser || action == Classify::Enum::LeftIfFurther) {
                  inter = left;
                  continueLoop = false;
              }
              else if (action == Classify::Enum::Right || action == Classify::Enum::RightIfCloser || action == Classify::Enum::RightIfFurther) {
                  inter = right;
                  continueLoop = false;
              }
              else if (action == Classify::Enum::AdvanceLeftLoop) {
                  //
                  float tmin = left.tmin + 0.1;
                  float3 normal;
                  float thit;
                  uint classification = -1;

                  bool hit = OtherRayCSGGeometryIntervals(ray, tmin, (AnalyticPrimitive::Enum)current.geometry, thit, normal);

                  if (hit) {
                      if (dot(ray.direction, normal) < 0) {
                          //entering
                          classification = 0;
                      }
                      else {
                          //exiting
                          classification = 1;
                      }
                  }
                  classificationInterval newLeft = { thit, classification, hit, normal };
                  left = newLeft;
                  //intersect with left sub node
              }
              else if (action == Classify::Enum::AdvanceRightLoop) {
                  float tmin = right.tmin + 0.1;
                  float3 normal;
                  float thit;
                  uint classification = -1;

                  bool hit = OtherRayCSGGeometryIntervals(ray, tmin, (AnalyticPrimitive::Enum)current.geometry, thit, normal);

                  if (hit) {
                      if (dot(ray.direction, normal) < 0) {
                          //entering
                          classification = 0;
                      }
                      else {
                          //exiting
                          classification = 1;
                      }
                  }
                  classificationInterval newRight = { thit, classification, hit, normal };
                  right = newRight;
              }
          }
          intersections[i] = inter;
      }*/




bool csgLoop(in Ray ray, inout classificationInterval left, inout classificationInterval right, inout classificationInterval inter, int type, inout bool revertLeft, inout bool revertRight, inout float min, in float elapsedTime) {
    Classify::Enum action;
    if (type == 0) {
       action = classifyIntersectionCSG(left, right);
    }
    else if (type == 1) {
       action = classifyIntersectionCSGIntersection(left, right);

    }
    else if (type == 2) {
        action = classifyDifference(left, right);
    }


    bool continueLoop = true;
    if (action == Classify::Enum::Miss) {
        //miss
        continueLoop = false;
        //return miss
    }
    else if (action == Classify::Enum::Left || action == Classify::Enum::LeftIfCloser || action == Classify::Enum::LeftIfFurther) {
        inter = left;
        continueLoop = false;
    }
    else if (action == Classify::Enum::Right || action == Classify::Enum::RightIfCloser || action == Classify::Enum::RightIfFurther || action == Classify::Enum::RightWithNormFlip) {
        
        if (action == Classify::Enum::
            RightWithNormFlip) {
            right.normal = -right.normal;
        }
        inter = right;
        continueLoop = false;
    }
    else if (action == Classify::Enum::AdvanceLeftLoop) {
        //
        if (left.geometry != -1) {
            float tmin = left.tmin + 0.01;
            float3 normal = float3(0, 0, 0);
            float thit = -1;
            uint classification = -1;

            bool hit = OtherRayCSGGeometryIntervals(ray, tmin, (AnalyticPrimitive::Enum)left.geometry, elapsedTime, thit, normal);

            if (hit) {
                if (dot(ray.direction, normal) < 0) {
                    //entering
                    classification = 0;
                }
                else {
                    //exiting
                    classification = 1;
                }
            }

            classificationInterval newLeft = { thit, classification, hit, normal, left.geometry };
            left = newLeft;
        }
        else {
            revertLeft = true;
            min = left.tmin + 0.01;

            //set revert to left node equal true, return
        }
        //intersect with left sub node
    }
    else if (action == Classify::Enum::AdvanceRightLoop) {
        if (right.geometry != -1) {
            float tmin = right.tmin + 0.01;
            float3 normal = float3(0, 0, 0);
            float thit = -1;
            uint classification = -1;

            bool hit = OtherRayCSGGeometryIntervals(ray, tmin, (AnalyticPrimitive::Enum)right.geometry, elapsedTime, thit, normal);

            if (hit) {
                if (dot(ray.direction, normal) < 0) {
                    //entering
                    classification = 0;
                }
                else {
                    //exiting
                    classification = 1;
                }
            }

            classificationInterval newRight = { thit, classification, hit, normal, right.geometry };
            right = newRight;
        }
        else {
            revertRight = true;
            min = right.tmin + 0.01;
        }
    }
    return continueLoop;
}



bool latestCSG(in Ray ray, out float thit, out ProceduralPrimitiveAttributes attr) {
    //we assume just an intersection filled tree at the moment
    //corresponding chosen t values @ index i of the post order traversal.
    classificationInterval intersections[10];
    CSGNode current = csgTree[0];
    uint depth = 1;
    int i = 0;
    float minimum = RayTMin();
    bool rollingLeft = false;
    bool rollingRight = false;
    uint originalIndex = 0;
    uint originalI;
    while (i < g_sceneCB.csgNodes){
        if (current.boolValue == -1) {
            //find nearest intersection 
            //Ray r;
          //  r.origin = ray.origin;
           // r.origin = ray.direction;
            float3 normal;
            float hitter;
            uint classification = -1;
            Ray r;
            //translate a lil
            r.origin = ray.origin + current.translation;
            r.direction = ray.direction;
            bool hit = OtherRayCSGGeometryIntervals(r, minimum, (AnalyticPrimitive::Enum)current.geometry, g_sceneCB.elapsedTime, hitter, normal);
            if (hit) {
                if (dot(ray.direction, normal) < 0) {
                    //entering
                    classification = 0;
                }
                else {
                    //exiting
                    classification = 1;
                }
            }
            classificationInterval inter = { hitter, classification, hit, normal, (AnalyticPrimitive::Enum)current.geometry };

            intersections[i] = inter;
            //interset with node, get closest hit

        }else {
          //we have a node;
          classificationInterval left = intersections[i - 2 * depth];
          classificationInterval right = intersections[i - 1];
          //want to classify the hits b
          bool continueLoop = true;
          //an action
          classificationInterval inter = { -1, -1, false, float3(0,0,0), (AnalyticPrimitive::Enum)current.geometry };

          bool revertLeft = false;
          bool revertRight = false;
          while (continueLoop) {
              continueLoop = csgLoop(ray, left, right, inter, current.boolValue, revertLeft, revertRight, minimum, g_sceneCB.elapsedTime);
              if (revertLeft == true) {
                  //left index is then (index) - 2*depth
                  uint index = i - 2 * depth;
                  rollingLeft = true;
                  originalIndex = index;
                  originalI = i;
                  while (intersections[index].geometry == -1) {
                      index = index - 2 * depth;

                  }
                  continueLoop = false;
                  revertLeft = false;
                  i = index - 1;
                  //find left most primitive of the current left tree
              }
              else if (revertRight == true) {
                  rollingRight = true;
                  uint index = i - 1;
                  originalIndex = index;
                  originalI = i;
                  //find left most primitive of right sub-tree
                  while (intersections[index].geometry == -1) {
                      index = index - 2*depth;
                  }
                  i = index - 1;
                  revertRight = false;
                  continueLoop = false;
                  //once we have the correct index we want to set i to this index, and start the loop from this point with the new value of t.
                  //find right most primitive of the current right tree
              }

          }
          if (!revertLeft || !revertRight) {
              intersections[i] = inter;
          }
      }

        if ((rollingLeft || rollingRight) && (i == originalIndex))
        {
            if (rollingLeft) {
                rollingLeft = false;
            }
            else {
                rollingRight = false;
            }
            i = originalI;
        }
        else {
            i += 1;
        }
        if ((i % 6) == 0) {
            depth += 1;
        }
        current = csgTree[i];
        

    }

    classificationInterval final = intersections[g_sceneCB.index];//intersections[i-1];

    if (final.hit) {
        if (final.tmin > RayTMin()) {
            thit = final.tmin;
            attr.normal = final.normal;
            if (dot(attr.normal, ray.direction) > 0) {
                attr.normal = -attr.normal;
            }
            return true;
        }
    }
    return false;
}

bool alternativeCSG(in Ray ray, out float thit, out ProceduralPrimitiveAttributes attr) {
    //tree is in post-order, just need to iterate the tree.
    uint2 p = DispatchRaysIndex().xy;
    intersectionInterval intersections[10];
    //g_renderTarget[p] = float4(1,0.2, 3, 0);
    CSGNode current = csgTree[0];
    int i = 0;
    int depth = 1;
    uint num;
    uint stride;
    csgTree.GetDimensions(num, stride);
    while(i < g_sceneCB.csgNodes) {
        //need to record depth
        if (current.boolValue == -1) {

            //trace a ray and find interesections - store
            float  tmin, tmax;
            float3 normal;
            Ray r;
            r.origin = ray.origin + current.translation;
            r.direction = ray.direction + current.translation;
            //r.direction = ray.direction + current.translation;
            float4 interval;
            uint count;
            bool hit = RayCSGGeometryIntervals(r, (AnalyticPrimitive::Enum)current.geometry, tmin, tmax, interval, normal, count);
            intersectionInterval inter = { tmin, tmax, hit, normal };
            //store this interval in the intersections array at   our node's index.
            intersections[i] = inter;
        }
        else {
            //retrieve intersections, and store
            intersectionInterval left = intersections[i - 2*depth];
            intersectionInterval right = intersections[i - 1];
            float tmin, tmax;
            float3 normal;
            bool hit;
            //combine the nodes
            CSGCombine(current.boolValue, left, right, tmin, tmax, normal, hit);
            intersectionInterval inter = { tmin, tmax, hit, normal };
            //store this interval in the intersections array at our node's index.
            intersections[i] = inter;

        }
        i += 1;
        current = csgTree[i];
        if ((i % 6) == 0) {
            depth += 1;
        }
    }
 

    intersectionInterval final = intersections[0];//intersections[i-1];

    if (final.hit) {
        if (final.tmin > RayTMin()) {
            thit = final.tmin;
            attr.normal = final.normal;
            return true;
        }
        else if (final.tmax > RayTMin()) {
            thit = final.tmax;
            attr.normal = final.normal;
            return true;

        }
    }
    return false;
}

bool RayCSGIntersectionTest(in Ray ray, in CSGPrimitive::Enum csgPrimitive, out float thit, out ProceduralPrimitiveAttributes attr) {
    float minL = 0;
    float minR = 0;
    bool visitedNodes[7] = { 0, 0,0,0,0,0, 0 };
    intersectionInterval intersections[15];
    CSGNode csgStack[15];
    int nodePointer = -1;
    bool entry = true;
   // csgStack[0] = csgTree[0];
    
    CSGNode root = csgTree[0];
    while (!isEmpty(csgStack, nodePointer) || entry) {
        entry = false;
        //works
        while (root.leftNodeIndex != -1 && !visitedNodes[root.myIndex]) {

            Push(csgStack, nodePointer, csgTree[root.rightNodeIndex]);
            Push(csgStack, nodePointer, root);

            root = csgTree[root.leftNodeIndex];
        }


        if (root.leftNodeIndex == -1 && !visitedNodes[root.myIndex]) {
            if (root.rightNodeIndex != -1) {
                Push(csgStack, nodePointer, csgTree[root.rightNodeIndex]);
            }
            Push(csgStack, nodePointer, root);
        }
        //works
        root = Pop(csgStack, nodePointer);
        //
        if ((root.rightNodeIndex != -1) && (csgStack[nodePointer].parentIndex == root.myIndex)) {
            CSGNode right = Pop(csgStack, nodePointer);
            Push(csgStack, nodePointer, root);
            root = right;
            //return fal
        }else {
            //evaluate node
            //intersect root.
          
            int index = root.myIndex;
            //works - or at least runs.
            if (root.boolValue == -1) {
                //primitive node
                float4 intersectionValues;
                float  tmin, tmax;
                float3 normal;
                uint count;
                bool hit = RayCSGGeometryIntervals(ray, (AnalyticPrimitive::Enum)root.geometry, tmin, tmax, intersectionValues, normal, count);
                //  float3 normal = attr.normal;
                      //intersect geometry
                intersectionInterval i = { tmin, tmax, hit, normal };
                //store this interval in the intersections array at our node's index.
                intersections[index] = i;
                visitedNodes[index] = true;

            }
            else {
              
                 //internal node
                 //get left node and right node intervals -- we know these have been stored since this is a postorder traversal
              
                //we certainly reach this.
                intersectionInterval left = intersections[root.leftNodeIndex];
                intersectionInterval right = intersections[root.rightNodeIndex];
                float tmin, tmax;
                float3 normal;
                bool hit;
                //combine the nodes
                CSGCombine(root.boolValue, left, right, tmin, tmax, normal, hit);

                //store the new tmin tmax value and normal at the node's index
                intersectionInterval interval = { tmin, tmax, hit, normal };
                intersections[index] = interval;
                visitedNodes[index] = true;

            }
        }
    }

    root = csgTree[0];
    intersectionInterval left = intersections[root.leftNodeIndex];
    intersectionInterval right = intersections[root.rightNodeIndex];
    float tmin, tmax;
    float3 normal;
    bool hit;

    CSGCombine(root.boolValue, left, right, tmin, tmax, normal, hit);
   
    /**
    intersectionInterval i = intersections[root.myIndex];
    float tmin = i.tmin;
    float tmax = i.tmax;
    float3 normal = i.normal;
    bool hit = i.hit*/
    
    if (hit) {
       if (tmin > RayTMin()) {
            thit = tmin;
            attr.normal = intersections[root.myIndex].normal;
            return true;

        }
        else if (tmax > RayTMin()) {
            thit = tmax;
            attr.normal = intersections[root.rightNodeIndex].normal;
            return true;

       }
        else {
           return false;
       }
    }
    return false;
}



[shader("intersection")]
void CSG_Intersection() {
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
   // AnalyticPrimitive::Enum primitiveType = (AnalyticPrimitive::Enum) l_aabbCB.primitiveType;

  CSGPrimitive::Enum primitiveType = (CSGPrimitive::Enum) l_aabbCB.primitiveType;
  // AnalyticPrimitive::Enum primitiveType = AnalyticPrimitive::Enum::Sphere;

    float thit;
    ProceduralPrimitiveAttributes attr;
   // if (RayCSGIntersectionTest(localRay, primitiveType, thit, attr)) {
    if (latestCSG(localRay, thit, attr)) {
    PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit, 0, attr);
    }
    //do a test based on the CSG tree.
    //look up ways to decompose the recursive structure of the CSG tree.
}
#endif // RAYTRACING_HLSL