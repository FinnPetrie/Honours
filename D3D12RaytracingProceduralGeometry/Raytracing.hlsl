
#ifndef RAYTRACING_HLSL
#define RAYTRACING_HLSL

#define HLSL
#include "RaytracingHlslCompat.h"
#include "ProceduralPrimitivesLibrary.hlsli"
#include "RaytracingShaderHelper.hlsli"

//***************************************************************************
//*****------ Shader resources bound via root signatures -------*************
//***************************************************************************

// Scene wide resources.
//  g_* - bound via a global root signature.
//  l_* - bound via a local root signature.
RaytracingAccelerationStructure g_scene : register(t0, space0);
RWTexture2D<float4> g_renderTarget : register(u0);
RWTexture2D<float4> g_rasterTarget : register(u1);

RWStructuredBuffer<Photon> photonBuffer : register(u2);
RWByteAddressBuffer photonBufferCounter : register(u3);
RWStructuredBuffer<uint> tiledPhotonMap : register(u9);

RWTexture2D<float4> GBufferBRDF : register(u4);
RWTexture2D<float4> GBufferPosition : register(u5);
RWTexture2D<float4> GBufferNormal : register(u6);


ConstantBuffer<SceneConstantBuffer> g_sceneCB : register(b0);



// Triangle resources
ByteAddressBuffer g_indices : register(t1, space0);
StructuredBuffer<Vertex> g_vertices : register(t2, space0);

// Procedural geometry resources
StructuredBuffer<PrimitiveInstancePerFrameBuffer> g_AABBPrimitiveAttributes : register(t3, space0);
StructuredBuffer<CSGNode> csgTree : register(t4, space0);

ConstantBuffer<PrimitiveConstantBuffer> l_materialCB : register(b1);
ConstantBuffer<PrimitiveInstanceConstantBuffer> l_aabbCB: register(b2);

groupshared uint photonSharedIndex = 0;

// Functions for PRNG
// http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
static uint rng_state;
//static const uint photonCount = 1000;
static const float TWO_PI = 6.2831853071795864769252867665590057683943f;
static const float INV_PI = 0.318309886f;

static const float PI = 3.1415926535897932384626422832795028841971f;
static const float SQRT_OF_ONE_THIRD = 0.5773502691896257645091487805019574556476f;

static const float prng_01_convert = (1.0f / 4294967296.0f); // Convert numbers generated by rand_xorshift to be between 0, 1
float rand_xorshift()
{
    // Xorshift algorithm from George Marsaglia's paper
    rng_state ^= uint(rng_state << 13);
    rng_state ^= uint(rng_state >> 17);
    rng_state ^= uint(rng_state << 5);
    return rng_state * prng_01_convert;
}
inline float3 SquareToSphereUniform(float2 samplePoint)
{
    float radius = 1.f;

    float phi = samplePoint.y * PI;
    float theta = samplePoint.x * TWO_PI;

    float3 result;
    result.x = radius * cos(theta) * sin(phi);
    result.y = radius * cos(phi);
    result.z = radius * sin(theta) * sin(phi);
    return result;
}


float3 lambertian(float3 normal, float3 pos, float3 materialColour) {
    //float3 lightDir =  normalize(g_sceneCB.lightPosition.xyz - pos);
    float3 lightDir = normalize(g_sceneCB.lightPosition - pos);
    float3 colour = materialColour / M_PI * g_sceneCB.lightDiffuseColor * max(0.f, dot(normal, lightDir));
    return  colour;
}

inline float3 calculateRandomDirectionInHemisphere(in float3 normal) {

    float up = sqrt(rand_xorshift()); // cos(theta)
    float over = sqrt(1 - up * up); // sin(theta)
    float around = rand_xorshift() * TWO_PI;

    // Find a direction that is not the normal based off of whether or not the
    // normal's components are all equal to sqrt(1/3) or whether or not at
    // least one component is less than sqrt(1/3). Learned this trick from
    // Peter Kutz.

    float3 directionNotNormal;
    if (abs(normal.x) < SQRT_OF_ONE_THIRD) {
        directionNotNormal = float3(1, 0, 0);
    }
    else if (abs(normal.y) < SQRT_OF_ONE_THIRD) {
        directionNotNormal = float3(0, 1, 0);
    }
    else {
        directionNotNormal = float3(0, 0, 1);
    }

    // Use not-normal direction to generate two perpendicular directions
    float3 perpendicularDirection1 =
        normalize(cross(normal, directionNotNormal));
    float3 perpendicularDirection2 =
        normalize(cross(normal, perpendicularDirection1));

    return up * normal
        + cos(around) * over * perpendicularDirection1
        + sin(around) * over * perpendicularDirection2;
}


float orenNayar(float3 v, float3 light, float3 normal, float roughness) {

    float roughness2 = roughness * roughness;
    float2 oren_nayar_fraction = roughness2 / (roughness2 + float2(0.33, 0.09));
    float2 oren_nayar = float2(1, 0) + float2(-0.5, 0.45) * oren_nayar_fraction;

    float2 cos_theta = saturate(float2(dot(normal, light), dot(normal, v)));
    float2 cos_theta2 = cos_theta * cos_theta;
    float sin_theta = sqrt((1 - cos_theta2.x) * (1 - cos_theta2.y));
    float3 light_plane = normalize(light - cos_theta.x * normal);
    float3 view_plane = normalize(v - cos_theta.y * normal);
    float cos_phi = saturate(dot(light_plane, view_plane));

    float diffuse_oren_nayar = cos_phi * sin_theta / max(cos_theta.x, cos_theta.y);
    float diffuse = cos_theta.x * (oren_nayar.x + oren_nayar.y * diffuse_oren_nayar);

    return diffuse;
}


float Fresnel(float3 wi, float3 normal, float3 eta) {
    float cosIncident = clamp(-1, 1, dot(wi, normal));
    float etaI = 1, etaT = eta;
    if (cosIncident > 0) {
        float temp = etaT;
        etaT = etaI;
        etaI = temp;
    }

    float sinT = etaI / etaT * sqrt(max(0.0f, 1 - cosIncident * cosIncident));

    if (sinT >= 1) {

        //total internal reflection, return probability of reflection = 1
        return 1;
    }
    else {
        float cosT = sqrt(max(0.0f, 1 - sinT * sinT));
        float cosI = abs(cosIncident);
        float Rs = ((etaT * cosI) - (etaI * cosT)) / ((etaT * cosI) + (etaI * cosT));
        float Rp = ((etaI * cosI) - (etaT * cosT)) / ((etaI * cosI) + (etaT * cosT));

        float fresn = (Rs * Rs + Rp * Rp) / 2;
        return fresn;
    }
}

float rand(in float2 uv) {
    float2 noise = (frac(sin(dot(uv, float2(12.9898, 78.233) * 2.0)) * 43758.5453));
    return abs(noise.x + noise.y) * 0.5;
}

float3 randomDirection(float2 ra) {
    float theta_0 = 2 * M_PI * rand(ra);
    float theta_1 = acos(1 - 2 * rand(ra));
    float3 dir = float3(sin(theta_0) * sin(theta_1), sin(theta_0)*cos(theta_1), sin(theta_1));
    return dir;
}



inline float3 SquareToDiskConcentric(in float2 sample)
{
    // Used Peter Shirley's concentric disk warp
    float radius;
    float angle;
    float a = (2 * sample[0]) - 1;
    float b = (2 * sample[1]) - 1;

    if (a > -b) {
        if (a > b) {
            radius = a;
            angle = (PI / 4.f) * (b / a);
        }
        else {
            radius = b;
            angle = (PI / 4.f) * (2 - (a / b));
        }
    }
    else {
        if (a < b) {
            radius = -a;
            angle = (PI / 4.f) * (4 + (b / a));
        }
        else {
            radius = -b;
            if (b != 0) {
                angle = (PI / 4.f) * (6 - (a / b));
            }
            else {
                angle = 0;
            }
        }
    }
    return float3(radius * cos(angle), radius * sin(angle), 0);
}

inline float3 SquareToHemisphereCosine(in float2 sample)
{
    // Used Peter Shirley's cosine hemisphere
    float3 disk = SquareToDiskConcentric(sample);
    return float3(disk[0], disk[1], sqrt(1.f - pow(length(disk), 2.f)));
}


inline float AbsCosTheta(in float3 w) {
    return abs(w.z);
}

inline bool SameHemisphere(in float3 w, in float3 wp) {
    return w.z * wp.z > 0;
}

inline float3 Lambert_Sample_f(in float3 wo, out float3 wi, in float2 samplePt, out float pdf, in float3 albedo) {
    wi = SquareToHemisphereCosine(samplePt);
    if (wo.z < 0) wi.z *= -1;
    wi = normalize(wi);
    pdf = SameHemisphere(wo, wi) ? INV_PI * AbsCosTheta(wi) : 0;

    return INV_PI * albedo;
}

float reflectionBRDF(float3 incomingDirection, float3 normal) {
    float3 n_in = normalize(-incomingDirection);
    float3 outgoing = reflect(n_in, normal);

    float thetaI = atan(n_in.y / n_in.x);
    float phiI = acos(n_in.z);


    float thetaO = atan(outgoing.y / outgoing.x);
    float phiO = acos(outgoing.z);

    float f_rs = 2 * (sin(thetaO) * sin(thetaO) - sin(thetaI) * sin(thetaI)) * (phiO - phiI);
    return f_rs;
}

float FresnelAmount(float n1, float n2, float3 normal, float3 incident) {
    float r0 = (n1 - n2) / (n1 + n2);
    r0 *= r0;
    float cosx = -dot(normal, incident);
    if (n1 > n2) {
        float n = n1 / n2;
        float sint = n * n*(1.0f - cosx * cosx);

        if (sint > 1.0) {
            return 1.0;
        }
        cosx = sqrt(1.0 - sint);
    }
    float x = 1.0 - cosx;
    float ret = r0 + (1.0f - r0) * x * x * x * x * x;
    ret = (l_materialCB.reflectanceCoef + (1.0 - l_materialCB.reflectanceCoef) * ret);
    return ret;
}


float PhongLighting(float3 normal, bool shadowHit) {
    float3 position = HitWorldPosition();
    float3 lightDir = normalize(g_sceneCB.lightPosition.xyz - position);
    float3 viewDir = normalize(-WorldRayDirection());
    float3 refl = normalize(reflect(normal, lightDir));
    float illum;
    if (l_materialCB.refractiveCoef == 0) {
         illum = l_materialCB.diffuseCoef * saturate(dot(lightDir, normal));

        illum += l_materialCB.specularCoef * pow(saturate(dot(refl,viewDir)), l_materialCB.specularPower);
    }
    else {
        illum = l_materialCB.specularCoef * pow(saturate(dot(refl, viewDir)), l_materialCB.specularPower);

    }
    if (!shadowHit) {

    }
    else {
       //llum = 0;

    }
    return illum;
}

bool refractTest(float3 v, float3 normal, float index, inout float3 refracted) {
    float dt = dot(v, normal);
    float discriminant = 1.0 - index * index * (1 - dt * dt);
    if (discriminant > 0) {
        refracted = index * (v - normal * dt) - normal * sqrt(discriminant);
        return true;
    }
    else {
        return false;
    }
}

PhotonPayload TracePhotonRay(in Ray ray, in PhotonPayload payload) {
    if (payload.recursionDepth >= MAX_RAY_RECURSION_DEPTH) {
        return payload;
    }

    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    // Set TMin to a zero value to avoid aliasing artifacts along contact areas.
    // Note: make sure to enable face culling so as to avoid surface face fighting.
    rayDesc.TMin = 0.01;
    rayDesc.TMax = 10000;

    payload.recursionDepth += 1;

    TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Radiance],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Radiance],
        rayDesc, payload);

    return payload;
}

// Trace a radiance ray into the scene and returns a shaded color.
RayPayload TraceRadianceRay(in Ray ray, in RayPayload payload)
{
    if (payload.recursionDepth >= MAX_RAY_RECURSION_DEPTH)
    {
       payload.color = float4(1,1,1, 1);
       return payload;
    }

    // Set the ray's extents.
    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    // Set TMin to a zero value to avoid aliasing artifacts along contact areas.
    // Note: make sure to enable face culling so as to avoid surface face fighting.
    rayDesc.TMin = 0.01;
    rayDesc.TMax = 10000;
  
    payload.recursionDepth += 1;

    TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Radiance],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Radiance],
        rayDesc, payload);

    return payload;
}



bool ShadowRay(in Ray ray, in UINT currentRayRecursionDepth) {

    if (currentRayRecursionDepth >= MAX_RAY_RECURSION_DEPTH)
    {
        return false;
    }


    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    rayDesc.TMin = 0.1;
    rayDesc.TMax = 10000;

    ShadowRayPayload shadow = { true };

    TraceRay(g_scene,
        RAY_FLAG_CULL_BACK_FACING_TRIANGLES
                   // ~skip any hit shaders
        | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Shadow],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Shadow],
        rayDesc, shadow);

    return shadow.hit;
}

inline void GetPixelPosition(float3 rayHitPosition, float2 screenDim, out uint2 pixelIndex, out bool inRange)
{
    float4 clippingCoord = mul(float4(rayHitPosition, 1), g_sceneCB.projection);
    clippingCoord.xyz /= clippingCoord.w;

    if (clippingCoord.z < 0.01f || clippingCoord.z > 1 || clippingCoord.x < -1 || clippingCoord.x > 1 || clippingCoord.y < -1 || clippingCoord.y > 1) {
        inRange = false;
        return;
    }

    inRange = true;
    pixelIndex.x = ((clippingCoord.x + 1.0) * 0.5f) * screenDim.x;
    pixelIndex.y = ((1.0 - clippingCoord.y) * 0.5f) * screenDim.y;
}


//photon mapping ray-gen
inline void GeneratePhoton(float2 samplePoint, float2 sampleSpace, out float3 origin, out float3 rayDir)
{
    //float2 normSample = samplePoint / sampleSpace;
    //rayDir = SquareToSphereUniform(normSample);
    origin = g_sceneCB.cameraPosition.xyz;

    // Use PRNG to generate ray direction
    float2 randomSample = float2(rand_xorshift(), rand_xorshift());
    rayDir = SquareToSphereUniform(randomSample);
}
uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}
float chessBoard(float3 pos) {

    float chess = floor(sqrt(pos.x * pos.x + pos.z * pos.z)) + floor(atan(pos.z / pos.x));
    // chess = floor(pos.x) + floor(pos.z);
    chess = frac(chess * 0.5);
    chess *= 2;
    if (chess == 0.0) {
        chess = 0.5;
    }
    return chess;
}

float3 getColour(float3 nDir) {
    float3 dir = normalize(WorldRayDirection());
    float t = 0.5 * (dir.y + 1.0);
    return (1.0 - t) * float3(1.0, 1.0, 1.0) + t * float3(0.52941176471, 0.80784313725, 0.98039215686);
}

inline void VisualizePhotonBuffer(float2 screenDims)
{
    // Get the Hit location of the photon
    for (int i = 0; i < 100; i++) {
        float3 hitPosition = photonBuffer[i].position.xyz;

        // Find the Screen Space Coord for the photon
        uint2 pixelPos;
        bool inRange;

        GetPixelPosition(hitPosition, screenDims, pixelPos, inRange);

        if (!inRange) {
            return;
        }

        // Shadow Ray.
        RayDesc ray;
        ray.Origin = hitPosition;
        //ray.Direction = normalize(g_sceneCB.cameraPosition.xyz - hitPosition);
        ray.Direction = g_sceneCB.cameraPosition.xyz - hitPosition;
        ray.TMin = 0.001;
        ray.TMax = 1.001;

        Ray r = { hitPosition, g_sceneCB.cameraPosition.xyz - hitPosition };
        ShadowRayPayload shadow = { true };


        TraceRay(g_scene,
            RAY_FLAG_CULL_BACK_FACING_TRIANGLES
            // ~skip any hit shaders
            | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
            TraceRayParameters::InstanceMask,
            TraceRayParameters::HitGroup::Offset[RayType::Shadow],
            TraceRayParameters::HitGroup::GeometryStride,
            TraceRayParameters::MissShader::Offset[RayType::Shadow],
            ray, shadow);

        if (!shadow.hit) {
            float2 tempPixel = pixelPos;
            tempPixel /= screenDims;
            g_renderTarget[pixelPos] += float4(hitPosition, 0)*100;
        }
    }

}
inline void VisualizePhoton(float4 photon, float4 colour, float2 screenDims)
{
    // Get the Hit location of the photon
    float3 hitPosition = photon.xyz;

    // Find the Screen Space Coord for the photon
    uint2 pixelPos;
    bool inRange;
    GetPixelPosition(hitPosition, screenDims, pixelPos, inRange);

    if (!inRange) {
        return;
    }

    // Shadow Ray.
    RayDesc ray;
    ray.Origin = hitPosition;
    //ray.Direction = normalize(g_sceneCB.cameraPosition.xyz - hitPosition);
    ray.Direction = g_sceneCB.cameraPosition.xyz - hitPosition;
    ray.TMin = 0.001;
    ray.TMax = 1.001;

    Ray r = { hitPosition, g_sceneCB.cameraPosition.xyz - hitPosition };
    ShadowRayPayload shadow = { true };
   

    TraceRay(g_scene,
        RAY_FLAG_CULL_BACK_FACING_TRIANGLES
        // ~skip any hit shaders
        | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Shadow],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Shadow],
        ray, shadow);
    
    if (!shadow.hit) {
        float2 tempPixel = pixelPos;
        tempPixel /= screenDims;
        g_renderTarget[pixelPos] = colour*1000;
    }

}

inline void GetTileIndex(float3 rayHitPosition, out uint tileIndex) {

    uint width, height;
    g_renderTarget.GetDimensions(width, height);

    float2 screenDim = float2(width, height);

    uint2 pixelIndex;
    bool inRange;
    GetPixelPosition(rayHitPosition, screenDim, pixelIndex, inRange);

    //suppose a tile is 64*64 pixels
    //order tiles in the following way
    //|1|2|3|4|
    //|5|6|7|8|
    //|9|10...|
    //|. .
    //|.   .
    //|.     .

    //classify pixel index
}

[shader("raygeneration")]
void CompositeRayGen() {
    //add corresponding RTVs together.
    uint2 index = DispatchRaysIndex().xy;
    g_renderTarget[index] += g_rasterTarget[index];
   /* for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            uint2 i = uint2(dx, dy);
            g_renderTarget[index] += g_renderTarget[i];
        }
    }

    g_renderTarget[index] = normalize(g_renderTarget[index]);*/
   // g_renderTarget[index] += float4(1, 1, 0, 0);
    //g_rasterTarget[index] = float4(1, 1, 0, 0);
    //
  //  g_rasterTarget[index] = g_renderTarget[index];
    //g_renderTarget[index] += g_rasterTarget[index];

}

[shader("closesthit")]
void CompositeHit(inout RayPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr) {
    //add corresponding RTVs together.
}
[shader("miss")]
void CompositeMiss(inout RayPayload rayPayload) {
    //add corresponding RTVs together.
}
[shader("raygeneration")]
void Photon_Ray_Gen() {

    //g_renderTarget[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
  /* for (int i = 0; i < 6; i++) {
        screenSpacePhoton[i][DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
        screenSpacePhotonColour[i][DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
        screenSpacePhotonDirection[i][DispatchRaysIndex().xy] = float4(0, 0, 0, 0);

    }*/
  //  photonBufferCounter.Store(0, 0);
    //AllMemoryBarrierWithGroupSync();

 

    float2 samplePoint = DispatchRaysIndex().xy;

  
    UINT currentRecursionDepth = 0;

 
    uint width, height;
    g_renderTarget.GetDimensions(width, height);
    float2 screenDims = float2(width, height);

    float power = 1/(width * height); //number of photons to be emitted

    PhotonPayload payload = { float4(0,0,0,0), g_sceneCB.lightDiffuseColor,
     power, 1, 0 };


    for (int i = 0; i < 1; i++) {
       // float3 direction = randomDirection(DispatchRaysIndex().xy + i);
        rng_state = uint(wang_hash(samplePoint.x + i + DispatchRaysDimensions().x * samplePoint.y));

        float2 rand = float2(rand_xorshift(), rand_xorshift());
        float3 dir = normalize(SquareToSphereUniform(rand));

        float3 origin = g_sceneCB.lightPosition;

        Ray ray = { origin, dir };
        /*RayDesc ray;
        ray.Origin = origin;
        ray.Direction = dir;
        ray.TMin = 0.001;
        ray.TMax = 10000.0;


       // Ray r = GenerateCameraRay(DispatchRaysIndex().xy, g_sceneCB.cameraPosition.xyz, g_sceneCB.projectionToWorld);
       */
        

        PhotonPayload traced = TracePhotonRay(ray, payload);
        //VisualizePhoton(traced.position, screenDims);
        //VisualizePhotonBuffer(screenDims);
        //VisualizePhotonBuffer(traced, screenDims);
       // VisualizePhoton(traced, screenDims);
    }

 
    // Write the raytraced color to the output texture.
  //  g_renderTarget[DispatchRaysIndex().xy] = traced.color;
    //send random ray light source
   // g_renderTarget[DispatchRaysIndex().xy] = float4(0, 1, 0, 1);

}
 inline float maxValue(in float3 w) {
    return max(w.x, max(w.y, w.z));
}

inline bool inscreenSpace(float3 intersection, float2 uv) {
    uint width, height;
    g_renderTarget.GetDimensions(width, height);

    float2 screenDims = float2(width, height);

    bool inRange;
    GetPixelPosition(intersection, screenDims, uv, inRange);

    if (inRange) {
        return true;
    }
    return false;
}

[shader("miss")]
void Photon_Miss(inout PhotonPayload payload) {
    //g_renderTarget[DispatchRaysIndex().xy] = BackgroundColor;

}

[shader("miss")]
void Photon_Shadow_Miss(inout ShadowRayPayload payload) {
    payload.hit = false;
}


[shader("closesthit")]
void ClosestHit_Photon_Triangle(inout PhotonPayload payload, in BuiltInTriangleIntersectionAttributes attr) {

    float3 pos = HitWorldPosition();

    uint indexSizeInBytes = 4;
    uint indicesPerTriangle = 3;
    uint triangleIndexStride = indicesPerTriangle * indexSizeInBytes;
    uint baseIndex = PrimitiveIndex() * triangleIndexStride;
    uint index = InstanceID();
    // Load up three 16 bit indices for the triangle.
    const uint3 indices = Load3x16BitIndices(baseIndex, g_indices);

    // Retrieve corresponding vertex normals for the triangle vertices.
    float3 triangleNormals[3] = { g_vertices[indices[0]].normal,
                                   g_vertices[indices[1]].normal,
                                    g_vertices[indices[2]].normal
    };

    float raySize = sqrt(dot(pos - WorldRayOrigin(), pos - WorldRayOrigin()));
    float3 normal = HitAttribute(triangleNormals, attr.barycentrics);
    


    float3 randDir = calculateRandomDirectionInHemisphere(normal);
    //compute cosine 
    float3 colour = float3(l_materialCB.albedo.x * payload.colour.x, l_materialCB.albedo.y * payload.colour.y, l_materialCB.albedo.z * payload.colour.z);
    payload.colour = float4(colour, 1);
    float3 dir = normalize(WorldRayDirection());

    //compute path probability
    
    //if diffuse surface, store photon
    if (l_materialCB.reflectanceCoef <= 0.0f && l_materialCB.refractiveCoef <= 0 && payload.recursionDepth > 1) {

    
        uint dstIndex = photonBuffer.IncrementCounter();
        Photon p = { float4(pos, raySize), float4(dir, 1), float4(colour, 1), float4(0, 1, 0, payload.probability)};

        if (dstIndex < PHOTON_COUNT) {
            photonBuffer[dstIndex] = p;
        }
        else {
           uint decr =  photonBuffer.DecrementCounter();
           return;

        }

    }

    float3 refractPos;
    float3 reflectPos;

    float maximumPower = maxValue(payload.colour);
  //  if (rand_xorshift() < (1.f - maximumPower)) {
    //    return;
    //}
    if (l_materialCB.refractiveCoef > 0) {
        //assume refractive glass
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, normal) > 0) {
            outwardNormal = -normal;
            index = n2;
        }
        else {
            outwardNormal = normal;
            index = n1 / n2;
        }
        if (refractTest(dir, outwardNormal, index, refracted)) {
            Ray r = { pos, refracted };
            refractPos =  TracePhotonRay(r, payload).position;
        }
        else {
            Ray r = { pos, reflect(dir, normal) };
            TracePhotonRay(r, payload);
            // refractionColour = TraceRadianceRay(r, rayPayload.recursionDepth);
        }
        float reflectMulti = FresnelAmount(n1, n2, normal, dir);
    }


    if (l_materialCB.reflectanceCoef > 0.1f) {
        Ray r = { pos, reflect(dir, normal) };
        //power of reflected photon should be scaled by the reflective property.
        payload.colour *= l_materialCB.reflectanceCoef;
        reflectPos = TracePhotonRay(r, payload).position;
    }

}

//don't need to define custom interesctions, since we will use the same as backward ray-tracing
[shader("closesthit")]
void ClosestHit_Photon_Procedural(inout PhotonPayload payload, in ProceduralPrimitiveAttributes attr) {
    //payload.colour = l_materialCB.albedo;

    float3 pos = HitWorldPosition();
  
    float3 dir = normalize(WorldRayDirection());
    float3 refractPos;
    float3 reflectPos;
    //payload.colour = l_materialCB.albedo;
    float3 colour =  float3(l_materialCB.albedo.x * payload.colour.x, l_materialCB.albedo.y * payload.colour.y, l_materialCB.albedo.z * payload.colour.z);
    payload.colour = float4(colour, 1);

    if (l_materialCB.reflectanceCoef <= 0.0f && l_materialCB.refractiveCoef <= 0 && payload.recursionDepth >= 1 ) {
      
        uint dstIndex = photonBuffer.IncrementCounter();
        float raySize = sqrt(dot(pos - WorldRayOrigin(), pos - WorldRayOrigin()));

        Photon p = { float4(pos, raySize), float4(dir, 1), float4(colour, 1), float4(attr.normal, payload.probability) };
        if (dstIndex < PHOTON_COUNT) {
            photonBuffer[dstIndex] = p;
        }
        else {
           uint decr = photonBuffer.DecrementCounter();
           return;

        }
    }

    //russian roulette
    float maximumPower = maxValue(payload.colour);
  //  if (rand_xorshift() < (1.f - maximumPower)) {
    //    return;
    //}

    if (l_materialCB.reflectanceCoef > 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        Ray r = { pos, reflect(dir, attr.normal) };
        reflectPos = TracePhotonRay(r, payload).position;
    }
    else if (l_materialCB.refractiveCoef > 0.0f) {
        float fresnel = Fresnel(dir, attr.normal, l_materialCB.refractiveCoef);
        bool outside = dot(dir, attr.normal) < 0 ? false : true;
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, attr.normal) > 0) {
            outwardNormal = -attr.normal;
            index = n2;
        }
        else {
            outwardNormal = attr.normal;
            index = n1 / n2;
        }
        refractTest(dir, outwardNormal, index, refracted);
        if (fresnel < 1) {

            Ray r = { pos, refracted };
            float temp = payload.probability;
            payload.probability = 2*(1 - fresnel);

            refractPos = TracePhotonRay(r, payload).position;
            payload.probability = temp;
            //setup refracted ray

        }

        float3 reflected = normalize(reflect(dir, attr.normal));
        Ray r = { pos, reflected };
        payload.probability = (fresnel);
        refractPos  = TracePhotonRay(r, payload).position;

        //hitColour += reflectionColour * fresnel + refractColour * (1 - fresnel);
    }

    //if refractive surface, trace photons based on law of refraction
   /* if (l_materialCB.refractiveCoef > 0) {
        //assume refractive glass
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, attr.normal) > 0) {
            outwardNormal = -attr.normal;
            index = n2;
        }
        else {
            outwardNormal = attr.normal;
            index = n1 / n2;
            if (refractTest(dir, outwardNormal, index, refracted)) {
                Ray r = { pos, refracted };
                payload.colour *= 2 * l_materialCB.refractiveCoef;
                TracePhotonRay(r, payload);
            }
            else {
                Ray r = { pos, reflect(dir, attr.normal) };
                // refractionColour = TraceRadianceRay(r, rayPayload.recursionDepth);
            }
            float reflectMulti = FresnelAmount(n1, n2, attr.normal, dir);
        }
        //evaluate colour via BRDF

        //if reflective surface, trace photons based on specular reflections.
        if (l_materialCB.reflectanceCoef > 0.1f) {
            Ray r = { pos, reflect(dir, attr.normal) };
          //  payload.colour *= 2*l_materialCB.reflectanceCoef;

            reflectPos = TracePhotonRay(r, payload).position;
        }

        // payload.position = float4(refractPos, 1);
        */

    }


PathTracingPayload TraceForwardPath(in Ray ray, in PathTracingPayload payload)
{
    if (payload.recursionDepth >= MAX_RAY_RECURSION_DEPTH)
    {
        payload.colour = float4(1, 1, 1, 1);
        return payload;
    }

    // Set the ray's extents.
    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    // Set TMin to a zero value to avoid aliasing artifacts along contact areas.
    // Note: make sure to enable face culling so as to avoid surface face fighting.
    rayDesc.TMin = 0.01;
    rayDesc.TMax = 10000;

    payload.recursionDepth += 1;

    //need to generate a new seed given the current seed.
    TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Radiance],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Radiance],
        rayDesc, payload);

    return payload;
}


[shader("raygeneration")]
void ForwardPathTracingRayGen() {
    float2 samplePoint = DispatchRaysIndex().xy;
    uint spp = g_sceneCB.spp;

    /*  for (int i = 0; i < 100; i++) {
        Photon p = photonBuffer[i + DispatchRaysIndex().x + i*DispatchRaysIndex().y];
        VisualizePhoton(p.position, p.colour, screenDims);
    }*/

    /*  for (int i = 0; i < 6; i++) {
          float4 photon = screenSpacePhoton[i][samplePoint];
          float4 colour = screenSpacePhotonColour[i][samplePoint];
          VisualizePhoton(photon, colour, screenDims);
      }*/

      // VisualizePhotonBuffer( screenDims);

    uint accumulatedFrames = g_sceneCB.accumulatedFrames;
   
    UINT currentRecursionDepth = 0;
    float3 radiance = 0.0f;
    if (accumulatedFrames == 0) {
        spp = 4;
    }
    for (int i = 0; i < spp; i++) {
        rng_state = uint(wang_hash(samplePoint.x + DispatchRaysDimensions().x * samplePoint.y + accumulatedFrames + i));

        float2 rand = float2(rand_xorshift(), rand_xorshift());

        float2 screen_coord = float2(samplePoint)+rand;

        
        Ray r = GenerateCameraRay(screen_coord, g_sceneCB.cameraPosition.xyz, g_sceneCB.projectionToWorld);

        //set seed.
        PathTracingPayload payload = { float4(0,0,0,0),rand.x, 0 };
        PathTracingPayload traced = TraceRadianceRay(r, payload);

       radiance += traced.colour;
    }

    radiance *= 1.0f / float(spp);
    float3 averageRadiance;
    if (accumulatedFrames == 0) {
        averageRadiance = radiance;
    }
    else {
        averageRadiance = lerp(g_renderTarget[DispatchRaysIndex().xy], radiance, 1.0f / (accumulatedFrames + 1.0f));
    }
    g_renderTarget[DispatchRaysIndex().xy] = float4(averageRadiance, 1.0f);

}





[shader("closesthit")]

void ForwardPathTracingClosestHitTriangle(inout PathTracingPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr) {

    //sammple the hemisphere of the BRDF and connect it to the light

    //want to connect this path to the light, evaluate radiance
    //L(x ,w ) = L_e(x, w) + L_dir(x, w) + L_indir(x, w)
    float3 normal = float3(0, 1, 0);

    uint indexSizeInBytes = 4;
    uint indicesPerTriangle = 3;
    uint triangleIndexStride = indicesPerTriangle * indexSizeInBytes;
    uint baseIndex = PrimitiveIndex() * triangleIndexStride;

    // Load up three 16 bit indices for the triangle.
    const uint3 indices = Load3x16BitIndices(baseIndex, g_indices);

    // Retrieve corresponding vertex normals for the triangle vertices.
    float3 triangleNormals[3] = { g_vertices[indices[0]].normal,
                                   g_vertices[indices[1]].normal,
                                    g_vertices[indices[2]].normal
    };

    float3 triangleNormal = HitAttribute(triangleNormals, attr.barycentrics);
    float3 pos = HitWorldPosition();
    float3 l_dir = g_sceneCB.lightPosition - pos;
    float c = chessBoard(pos);

    Ray shadowRay;
    shadowRay.origin = HitWorldPosition();
    shadowRay.direction = l_dir;
    bool shadowHit = ShadowRay(shadowRay, rayPayload.recursionDepth);
    float4 reflectionColour = float4(0, 0, 0, 0);

    float3 diffuseColour = float4(c, c, c, 0);

    float4 randomSampleColour = float4(0, 0, 0, 0);
    if (shadowHit) {
        diffuseColour *= 0.5;
    }
    diffuseColour *= orenNayar(normalize(WorldRayDirection()), normal, normalize(l_dir), 1);

  



    if (l_materialCB.reflectanceCoef > 0) {
        Ray r = { HitWorldPosition(), reflect(WorldRayDirection(), triangleNormal) };
        reflectionColour += TraceForwardPath(r, rayPayload).colour;

    }
    else {

        rng_state = wang_hash(length(pos));
        float3 randomDirectionInHemisphere = calculateRandomDirectionInHemisphere(normal);

        Ray r = { HitWorldPosition(), randomDirectionInHemisphere };
        randomSampleColour += TraceForwardPath(r, rayPayload).colour;
    }

    //color = lerp(color, BackgroundColor, 1.0 - exp(-0.000002 * t * t * t))
    rayPayload.colour = float4(diffuseColour, 0) + randomSampleColour;

}


[shader("closesthit")]

void ForwardPathTracingClosestHitProcedural(inout PathTracingPayload rayPayload, in ProceduralPrimitiveAttributes attr) {
    //want to connect this path to the light, evaluate radiance

    rayPayload.colour = float4(0.43, 1, 0, 0);


}

[shader("miss")]

void MissPathTracing(inout PathTracingPayload rayPayload) {

}

[shader("raygeneration")]
void LightTracingRayGen() {


}





[shader("closesthit")]

void LightTracingClosestHitTriangle(inout PathTracingPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr) {


}


[shader("closesthit")]

void LightTracingClosestHitProcedural(inout PathTracingPayload rayPayload, in ProceduralPrimitiveAttributes attr) {


}

















































































//***************************************************************************
//********************------ Ray gen shader.. -------************************
//***************************************************************************
[shader("raygeneration")]
void MyRaygenShader()
{    
    g_renderTarget[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);

   // g_rasterTarget[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);

   // photonBufferCounter.Store(0, 0);

    //photonBuffer.DecrementCounter();
    float2 samplePoint = DispatchRaysIndex().xy;

    uint width;
    uint height;
    g_renderTarget.GetDimensions(width, height);
    float2 screenDims = float2(width, height);

    GBufferBRDF[DispatchRaysIndex().xy] = float4(0,0,0, 0);
    GBufferPosition[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
    GBufferNormal[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);


    /*  for (int i = 0; i < 100; i++) {
        Photon p = photonBuffer[i + DispatchRaysIndex().x + i*DispatchRaysIndex().y];
        VisualizePhoton(p.position, p.colour, screenDims);
    }*/

  /*  for (int i = 0; i < 6; i++) {
        float4 photon = screenSpacePhoton[i][samplePoint];
        float4 colour = screenSpacePhotonColour[i][samplePoint];
        VisualizePhoton(photon, colour, screenDims);
    }*/
       
   // VisualizePhotonBuffer( screenDims);

    rng_state = uint(wang_hash(samplePoint.x + DispatchRaysDimensions().x * samplePoint.y));

    UINT currentRecursionDepth = 0;
  Ray r = GenerateCameraRay(DispatchRaysIndex().xy, g_sceneCB.cameraPosition.xyz, g_sceneCB.projectionToWorld);
 //   Ray r = { ray.Origin, ray.Direction };
    RayPayload payload = { float4(0,0,0,0), 
        0,
        0 };
    //RayPayload traced = TraceRadianceRay(ray, payload);
    RayPayload traced = TraceRadianceRay(r, payload);

    // Write the raytraced color to the output texture.
    g_renderTarget[DispatchRaysIndex().xy] =  traced.color; //+ screenSpacePhotonMap[0][samplePoint];
    //uint offset = 0;

    //if drawing rays,   need to write the intersections for this ray into a 3D tensor.

}



//***************************************************************************
//******************------ Closest hit shaders -------***********************
//***************************************************************************

//implement a BRDF microfacet for the ground
[shader("closesthit")]
void MyClosestHitShader_Triangle(inout RayPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr)
{
    uint indexSizeInBytes = 4;
    uint indicesPerTriangle = 3;
    uint triangleIndexStride = indicesPerTriangle * indexSizeInBytes;
    uint baseIndex = PrimitiveIndex() * triangleIndexStride;

    // Load up three 16 bit indices for the triangle.
    const uint3 indices = Load3x16BitIndices(baseIndex, g_indices);

    // Retrieve corresponding vertex normals for the triangle vertices.
    float3 triangleNormals[3] = { g_vertices[indices[0]].normal,
                                   g_vertices[indices[1]].normal,
                                    g_vertices[indices[2]].normal
    };

    float3 triangleNormal = HitAttribute(triangleNormals, attr.barycentrics);
    float4 ambient = l_materialCB.albedo;
    float3 hitPos = HitWorldPosition();
    float3 pos = HitWorldPosition();
    float3 dir = normalize(g_sceneCB.lightPosition.xyz - pos);
    float3 r_dir = randomDirection(HitWorldPosition().xy);
    float3 l_dir = g_sceneCB.lightPosition.xyz - hitPos;
    float3 pos_n =normalize(HitWorldPosition());

    uint depth = rayPayload.recursionDepth;

   
    float c = chessBoard(pos);

    Ray shadowRay;
    shadowRay.origin = HitWorldPosition();
    shadowRay.direction = dir;
    bool shadowHit = ShadowRay(shadowRay, rayPayload.recursionDepth);
    float3 normal = float3(0, 1, 0);
    float4 reflectionColour = float4(0, 0, 0, 0);
    
    float3 diffuseColour = float4(c, c, c, 0);

   
        //if immediate ray - i.e., recursion depth = 1
    if (rayPayload.recursionDepth == 1) {
        //store normal, and other elements in relevant GBuffer

        //for some reason the triangle normal is not working??! - for now just suppose n = (0, -1, 0)
        GBufferBRDF[DispatchRaysIndex().xy] = float4(diffuseColour, 1);
        GBufferPosition[DispatchRaysIndex().xy] = float4(pos, 0);
        GBufferNormal[DispatchRaysIndex().xy] = float4(0, 1, 0, 0);
    }

    if (shadowHit) {
        diffuseColour *= 0.5;
    }
   diffuseColour *= orenNayar(normalize(WorldRayDirection()), normal, normalize(l_dir), 1);
    



    
      if(l_materialCB.reflectanceCoef > 0){
        Ray r = { HitWorldPosition(), reflect(WorldRayDirection(), triangleNormal) };
        reflectionColour = TraceRadianceRay(r, rayPayload).color;

    }

    float4 color =  float4(diffuseColour.xyz, 0) + 0.15*reflectionColour;
    float t = RayTCurrent();
  //color = lerp(color, BackgroundColor, 1.0 - exp(-0.000002 * t * t * t));
    float3 colour;

    //rayPayload.color = color;
   // rayPayload.color = float4(colour, 0);
    float4 backColour = float4(getColour(normalize(WorldRayDirection())), 1);
    rayPayload.color = color;
    //rayPayload.color =  lerp(color, backColour, 1.0 - exp(-0.000002 * t * t * t)) + float4(colour, 0);

   // rayPayload.intersections[rayPayload.recursionDepth] = color;


}

//implement fresnel




[shader("closesthit")]
void MyClosestHitShader_AABB(inout RayPayload rayPayload, in ProceduralPrimitiveAttributes attr)
{   

    float3 pos = HitWorldPosition();
    float3 pos_n = normalize(HitWorldPosition());

    //intersectionBuffer[rayPayload.recursionDepth][DispatchRaysIndex().xy] = normalize(float4(pos, 1));
   
    //g_buffer[1080*y + x] = float4(pos, 1);
    float3 l_dir = normalize(g_sceneCB.lightPosition.xyz - pos);
    float4 reflectionColour = float4(0,0,0,1);
    Ray shadowRay = { pos, l_dir };
    float3 currentDir = RayTCurrent() * WorldRayDirection();
    currentDir += WorldRayOrigin();
    
    bool shadowHit = ShadowRay(shadowRay, rayPayload.recursionDepth);


    if (rayPayload.recursionDepth == 1) {
        //store normal, and other elements in relevant GBuffer
        float3 l = lambertian(attr.normal, pos, l_materialCB.albedo);
        GBufferBRDF[DispatchRaysIndex().xy] = float4(l, 0);
        GBufferPosition[DispatchRaysIndex().xy] = float4(pos, 0);
        GBufferNormal[DispatchRaysIndex().xy] = float4(attr.normal, 0);
    }

    float3 hitColour = float3(0, 0, 0);
    if (!shadowHit) {
        //ambient += 0.1*PhongLighting(float4(attr.normal, 0), shadowHit);
    }
    float3 dir = normalize(WorldRayDirection());
    float4 refractColour = float4(0, 0, 0, 0);
    if (l_materialCB.reflectanceCoef > 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        Ray r = { pos, reflect(dir, attr.normal) };
        reflectionColour = TraceRadianceRay(r, rayPayload).color;
        hitColour += reflectionColour;

    }
    else if (l_materialCB.refractiveCoef > 0.0f) {
        float fresnel = Fresnel(dir, attr.normal, l_materialCB.refractiveCoef);
        bool outside = dot(dir, attr.normal) < 0 ? false : true;
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, attr.normal) > 0) {
            outwardNormal = -attr.normal;
            index = n2;
        }
        else {
            outwardNormal = attr.normal;
            index = n1 / n2;
        }
        refractTest(dir, outwardNormal, index, refracted);
        if (fresnel < 1) {

            Ray r = { pos, refracted };
            refractColour = TraceRadianceRay(r, rayPayload).color;
            //setup refracted ray
        
        }

        float3 reflected = normalize(reflect(dir, attr.normal));
        Ray r = { pos, reflected };
        reflectionColour = TraceRadianceRay(r, rayPayload).color;

        hitColour += reflectionColour * fresnel + refractColour * (1 - fresnel);
    }
    else {
        hitColour = l_materialCB.albedo * orenNayar(normalize(WorldRayDirection()), attr.normal, normalize(l_dir), 1);
       // hitColour =   lambertian(attr.normal, pos, l_materialCB.albedo);
    }
    float re = reflectionBRDF(dir, attr.normal);

//0.1f is a good coefficient for reflectioncolour.
 // rayPayload.color += refractionColour + 0.1*reflectionColour;
//  rayPayload.color = refractionColour;
float4 colour =  l_materialCB.albedo + float4(hitColour.xyz, 0);

//ray
//float3 sky = lerp(float3(0.52, 0.77, 1), float3(0.12, 0.43, 1), BackgroundColor.xyz);

float t = RayTCurrent();
float4 backColour = float4(getColour(normalize(WorldRayDirection())), 1);
//rayPayload.color = lerp(colour, backColour, 1.0 - exp(-0.000002 * t * t * t));
rayPayload.color = colour;
}

//***************************************************************************
//**********************------ Miss shaders -------**************************
//***************************************************************************



[shader("miss")]
void MyMissShader(inout RayPayload rayPayload)
{
   // float transition = pow(smoothstep(0.02, .5, d.y), 0.4);
//
    float3 ndir = normalize(WorldRayDirection());
   
    rayPayload.color = float4(getColour(ndir), 1);
   // float4 backgroundColor = float4(BackgroundColor);
    uint depth = rayPayload.recursionDepth;
    //float3 sky = lerp(float3(0.52, 0.77, 1), float3(0.12, 0.43, 1), BackgroundColor);
  //  rayPayload.color = BackgroundColor;
    //rayPayload.color =  float4(lerp(SkyColour.xyz, float3(0.4, 0.4, 0.4), float4(BackgroundColor)), 1);
    //g_renderTarget[DispatchRaysIndex().xy] = rayPayload.color;
   // intersectionBuffer[depth][DispatchRaysIndex().xy] = float4(0,0,0,0);

}

[shader("miss")]
void MyMissShader_ShadowRay(inout ShadowRayPayload rayPayload)
{


    rayPayload.hit = false;
}


//***************************************************************************
//**********************------ Any Hit Shaders -------**************************
//***************************************************************************
[shader("anyhit")]
void AnyHit_AnalyticPrimitive(inout RayPayload payload, in ProceduralPrimitiveAttributes attr) {
    //IgnoreHit();
    float3 pos = HitWorldPosition();
    if (l_materialCB.refractiveCoef > 0) {
        //  if(ShadowRay(payload)){}
         // payload.color = float4(1, 1, 0, 1);
         //IgnoreHit();
    }
    // payload.color = float4(1, 1, 0, 1);
}

[shader("anyhit")]
void AnyHit_Triangle(inout RayPayload payload, in BuiltInTriangleIntersectionAttributes attr) {
    // payload.color = float4(0, 0, 0, 1);
    //IgnoreHit();
}
//***************************************************************************
//*****************------ Intersection shaders-------************************
//***************************************************************************


[shader("closesthit")]
void ClosestHit_CSG( inout RayPayload payload, in ProceduralPrimitiveAttributes attr){

}
// Get ray in AABB's local space.
Ray GetRayInAABBPrimitiveLocalSpace()
{
    PrimitiveInstancePerFrameBuffer attr = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];

    // Retrieve a ray origin position and direction in bottom level AS space 
    // and transform them into the AABB primitive's local space.
    Ray ray;
    ray.origin = mul(float4(ObjectRayOrigin(), 1), attr.bottomLevelASToLocalSpace).xyz;
    ray.direction = mul(ObjectRayDirection(), (float3x3) attr.bottomLevelASToLocalSpace);
    return ray;
}

[shader("intersection")]
void MyIntersectionShader_AnalyticPrimitive()
{
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
    AnalyticPrimitive::Enum primitiveType = (AnalyticPrimitive::Enum) l_aabbCB.primitiveType;
   // AnalyticPrimitive::Enum primitiveType = AnalyticPrimitive::Enum::Plane;
    float thit;
    ProceduralPrimitiveAttributes attr;
    if (RayAnalyticGeometryIntersectionTest(localRay, primitiveType, thit, attr))
    {
        PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit, /*hitKind*/ 0, attr);
    }
}

[shader("intersection")]
void MyIntersectionShader_VolumetricPrimitive()
{
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
    VolumetricPrimitive::Enum primitiveType = (VolumetricPrimitive::Enum) l_aabbCB.primitiveType;
    
    float thit;
    ProceduralPrimitiveAttributes attr;
  
}

[shader("intersection")]
void MyIntersectionShader_SignedDistancePrimitive()
{
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
    SignedDistancePrimitive::Enum primitiveType = (SignedDistancePrimitive::Enum) l_aabbCB.primitiveType;

    float thit;
    ProceduralPrimitiveAttributes attr;

    if (RaySignedDistancePrimitiveTest(localRay, primitiveType, thit, attr, l_materialCB.stepScale))
    {
        PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit, /*hitKind*/ 0, attr);
    }
 
}



bool isEmpty(CSGNode csgStack[15], int nodePointer) {
    if (nodePointer <= -1) {
        return true;
    }
    return false;
}


void Push(inout CSGNode csgStack[15], inout int nodePointer, CSGNode node) {
    nodePointer += 1;
    csgStack[nodePointer] = node;
}

CSGNode Pop(inout CSGNode csgStack[15], inout int nodePointer) {
    CSGNode popped = csgStack[nodePointer];
    nodePointer -= 1;
    return popped;
}


void CSGCombine(in int operation, in intersectionInterval left, in intersectionInterval right, inout float tmin, inout float tmax, inout float3 normal, inout bool hit) {
  
    if (operation == 0) {
        if (left.hit && right.hit) {
            //union
            //get smallest and largest values over all intersections -- will need to record whether there were intersections for the subtrees
            tmin = min(left.tmin, right.tmin);
            tmax = max(left.tmax, right.tmax);
            if (tmin == left.tmin) {
                normal = left.normal;
            }
            else {
                normal = right.normal;
            }
            hit = true;
        }
        //else we don't intersect one of the subtrees
        else {
            if (right.hit) {
                tmin = right.tmin;
                tmax = right.tmax;
                normal = right.normal;
                hit = true;
            }
            else if(left.hit){
                tmin = left.tmin;
                tmax = left.tmax;
                normal = left.normal;
                hit = true;
            }
            else {
                tmin = -1;
                tmax = -1;
                normal = float3(0, 0, 0);
                hit = false;
            }
        }
    }




    else if (operation == 1) {
        //intersection
        if (left.hit && right.hit) {
            float e = max(left.tmin, right.tmin);
            float f = min(left.tmax, right.tmax);
            hit = true;
            tmin = min(e, f);
            tmax = max(e, f);

            if (tmin == e) {
                if (e == left.tmin) {
                    normal = left.normal;
                }
                else {
                    normal = right.normal;
                }
            }
        }
        else {
            tmin = -1;
            tmax = -1;
            normal = float3(0, 0, 0);
            hit = false;
        }
    }





    else {
        /*
    if (sphere_hit && hyp_hit) {
        intersections = float4(b_tmin, b_tmax, s_tmin, s_tmax);
        if(intersections.x < intersections.z){
            thit = intersections.x;
            attr = b_attr;
        }
        else if (intersections.w < intersections.y) {
            thit = intersections.w;
            attr.normal = -s_attr.normal;
        }
        else {
            return false;
        }

        return true;
        //return Intersection(intersections, thit, s_attr, b_attr, attr);
    }

    if (hyp_hit) {
        thit = t_hit;
        attr = b_attr;
        return true;
    }
    return false;
*/

    //difference
        if (right.hit && left.hit) {
            if (right.tmin < left.tmin) {
                tmin = right.tmin;
                tmax = left.tmin;
                normal = right.normal;
                hit = true;

            }
            else if (left.tmax < right.tmax) {
                tmin = left.tmax;
                tmax = right.tmax;
                normal = -left.normal;
                hit = true;

            }
            else {
                tmin = -1;
                tmax = -1;
                normal = float3(0, 0, 0);
                hit = false;
                
            }
        }
        else {
            if (right.hit) {
                tmin = right.tmin;
                tmax = right.tmax;
                normal = right.normal;
                hit = true;
            }
            else {
                tmin = -1;
                tmax = -1;
                normal = float3(0, 0, 0);
                hit = false;
            }
        }
    }

    
}
bool alternativeCSG(in Ray ray, out float thit, out ProceduralPrimitiveAttributes attr) {
    //tree is in post-order, just need to iterate the tree.

    intersectionInterval intersections[10];
    CSGNode current = csgTree[0];
    int i = 0;
    int depth = 1;
    uint num;
    uint stride;
    csgTree.GetDimensions(num, stride);
    while(i < 7) {
        //need to record depth
        if (current.boolValue == -1) {

            //trace a ray and find interesections - store
            float  tmin, tmax;
            float3 normal;
            Ray r;
            r.origin = ray.origin + current.translation;
            r.direction = ray.direction + current.translation;
            //r.direction = ray.direction + current.translation;
            bool hit = RayCSGGeometryIntervals(r, (AnalyticPrimitive::Enum)current.geometry, tmin, tmax, normal);
            intersectionInterval inter = { tmin, tmax, hit, normal };
            //store this interval in the intersections array at   our node's index.
            intersections[i] = inter;
        }
        else {
            //retrieve intersections, and store
            intersectionInterval left = intersections[i - 2*depth];
            intersectionInterval right = intersections[i - 1];
            float tmin, tmax;
            float3 normal;
            bool hit;
            //combine the nodes
            CSGCombine(current.boolValue, left, right, tmin, tmax, normal, hit);
            intersectionInterval inter = { tmin, tmax, hit, normal };
            //store this interval in the intersections array at our node's index.
            intersections[i] = inter;

        }
        i += 1;
        current = csgTree[i];
        if (i % 6 == 0) {
            depth += 1;
        }
    }
 

    intersectionInterval final = intersections[i-1];

    if (final.hit) {
        if (final.tmin > RayTMin()) {
            thit = final.tmin;
            attr.normal = final.normal;
            return true;
        }
        else if (final.tmax > RayTMin()) {
            thit = final.tmax;
            attr.normal = final.normal;
            return true;

        }
    }
    return false;
}

bool RayCSGIntersectionTest(in Ray ray, in CSGPrimitive::Enum csgPrimitive, out float thit, out ProceduralPrimitiveAttributes attr) {
    float minL = 0;
    float minR = 0;
    bool visitedNodes[7] = { 0, 0,0,0,0,0, 0 };
    intersectionInterval intersections[15];
    CSGNode csgStack[15];
    int nodePointer = -1;
    bool entry = true;
   // csgStack[0] = csgTree[0];
    
    CSGNode root = csgTree[0];
    while (!isEmpty(csgStack, nodePointer) || entry) {
        entry = false;
        //works
        while (root.leftNodeIndex != -1 && !visitedNodes[root.myIndex]) {

            Push(csgStack, nodePointer, csgTree[root.rightNodeIndex]);
            Push(csgStack, nodePointer, root);

            root = csgTree[root.leftNodeIndex];
        }


        if (root.leftNodeIndex == -1 && !visitedNodes[root.myIndex]) {
            if (root.rightNodeIndex != -1) {
                Push(csgStack, nodePointer, csgTree[root.rightNodeIndex]);
            }
            Push(csgStack, nodePointer, root);
        }
        //works
        root = Pop(csgStack, nodePointer);
        //
        if ((root.rightNodeIndex != -1) && (csgStack[nodePointer].parentIndex == root.myIndex)) {
            CSGNode right = Pop(csgStack, nodePointer);
            Push(csgStack, nodePointer, root);
            root = right;
            //return fal
        }else {
            //evaluate node
            //intersect root.
          
            int index = root.myIndex;
            //works - or at least runs.
            if (root.boolValue == -1) {
                //primitive node

                float  tmin, tmax;
                float3 normal;
                bool hit = RayCSGGeometryIntervals(ray, (AnalyticPrimitive::Enum)root.geometry, tmin, tmax, normal);
                //  float3 normal = attr.normal;
                      //intersect geometry
                intersectionInterval i = { tmin, tmax, hit, normal };
                //store this interval in the intersections array at our node's index.
                intersections[index] = i;
                visitedNodes[index] = true;

            }
            else {
              
                 //internal node
                 //get left node and right node intervals -- we know these have been stored since this is a postorder traversal
              
                //we certainly reach this.
                intersectionInterval left = intersections[root.leftNodeIndex];
                intersectionInterval right = intersections[root.rightNodeIndex];
                float tmin, tmax;
                float3 normal;
                bool hit;
                //combine the nodes
                CSGCombine(root.boolValue, left, right, tmin, tmax, normal, hit);

                //store the new tmin tmax value and normal at the node's index
                intersectionInterval interval = { tmin, tmax, hit, normal };
                intersections[index] = interval;
                visitedNodes[index] = true;

            }
        }
    }

    root = csgTree[0];
    intersectionInterval left = intersections[root.leftNodeIndex];
    intersectionInterval right = intersections[root.rightNodeIndex];
    float tmin, tmax;
    float3 normal;
    bool hit;

    CSGCombine(root.boolValue, left, right, tmin, tmax, normal, hit);
   
    /**
    intersectionInterval i = intersections[root.myIndex];
    float tmin = i.tmin;
    float tmax = i.tmax;
    float3 normal = i.normal;
    bool hit = i.hit*/
    
    if (hit) {
       if (tmin > RayTMin()) {
            thit = tmin;
            attr.normal = intersections[root.myIndex].normal;
            return true;

        }
        else if (tmax > RayTMin()) {
            thit = tmax;
            attr.normal = intersections[root.rightNodeIndex].normal;
            return true;

       }
        else {
           return false;
       }
    }
    return false;
}



[shader("intersection")]
void CSG_Intersection() {
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
   // AnalyticPrimitive::Enum primitiveType = (AnalyticPrimitive::Enum) l_aabbCB.primitiveType;

  CSGPrimitive::Enum primitiveType = (CSGPrimitive::Enum) l_aabbCB.primitiveType;
  // AnalyticPrimitive::Enum primitiveType = AnalyticPrimitive::Enum::Sphere;

    float thit;
    ProceduralPrimitiveAttributes attr;
   // if (RayCSGIntersectionTest(localRay, primitiveType, thit, attr)) {
    if (alternativeCSG(localRay, thit, attr)) {
    PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit, 0, attr);
    }
    //do a test based on the CSG tree.
    //look up ways to decompose the recursive structure of the CSG tree.
}
#endif // RAYTRACING_HLSL