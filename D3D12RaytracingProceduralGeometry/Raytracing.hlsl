
#ifndef RAYTRACING_HLSL
#define RAYTRACING_HLSL

#define HLSL
#include "RaytracingHlslCompat.h"
#include "ProceduralPrimitivesLibrary.hlsli"
#include "RaytracingShaderHelper.hlsli"

//***************************************************************************
//*****------ Shader resources bound via root signatures -------*************
//***************************************************************************

// Scene wide resources.
//  g_* - bound via a global root signature.
//  l_* - bound via a local root signature.
RaytracingAccelerationStructure g_scene : register(t0, space0);
RWTexture2D<float4> g_renderTarget : register(u0);
RWTexture2D<float4> g_rasterTarget : register(u1);

RWStructuredBuffer<Photon> photonBuffer : register(u2);
RWByteAddressBuffer photonBufferCounter : register(u3);
//RWStructuredBuffer<uint> tiledPhotonMap : register(u9);

RWTexture2D<float4> GBufferBRDF : register(u4);
RWTexture2D<float4> GBufferPosition : register(u5);
RWTexture2D<float4> GBufferNormal : register(u6);
RWTexture2D<float4> staging : register(u7);
RWTexture2D<float4> lightTracingPhotons [MAX_RAY_RECURSION_DEPTH*4]: register(u8);



ConstantBuffer<SceneConstantBuffer> g_sceneCB : register(b0);



// Triangle resources
ByteAddressBuffer g_indices : register(t1, space0);
StructuredBuffer<Vertex> g_vertices : register(t2, space0);

// Procedural geometry resources
StructuredBuffer<PrimitiveInstancePerFrameBuffer> g_AABBPrimitiveAttributes : register(t3, space0);
StructuredBuffer<CSGNode> csgTree : register(t4, space0);

ConstantBuffer<PrimitiveConstantBuffer> l_materialCB : register(b1);
ConstantBuffer<PrimitiveInstanceConstantBuffer> l_aabbCB: register(b2);

groupshared uint photonSharedIndex = 0;

// Functions for PRNG
// http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
static uint rng_state;
//static const uint photonCount = 1000;
static const float TWO_PI = 6.2831853071795864769252867665590057683943f;
static const float INV_PI = 0.318309886f;

static const float PI = 3.1415926535897932384626422832795028841971f;
static const float SQRT_OF_ONE_THIRD = 0.5773502691896257645091487805019574556476f;

static const float prng_01_convert = (1.0f / 4294967296.0f); // Convert numbers generated by rand_xorshift to be between 0, 1

float2 hash2(inout float seed) {
    return frac(sin(float2(seed += 0.1, seed += 0.1)) * float2(43758.5453123, 22578.1459123));
}





float3 lambertian(float3 normal, float3 pos, float3 materialColour) {
    //float3 lightDir =  normalize(g_sceneCB.lightPosition.xyz - pos);
    float3 lightDir = normalize(g_sceneCB.lightSphere.xyz - pos);
    float3 colour = materialColour*g_sceneCB.lightPower / M_PI * max(0.f, dot(normal, lightDir));
    return  colour;
}

float rand_ik(inout uint seed)
{
    float result = frac(sin(seed / 100.0f * dot(DispatchRaysIndex().xy, float2(12.9898f, 78.233f))) * 43758.5453f);
    seed += 1.0f;
    return result;
}

float3 cosWeightedRandomHemisphereDirection(const float3 n, inout float seed) {
    float2 r = hash2(seed);

    float3  uu = normalize(cross(n, float3(0.0, 1.0, 1.0)));
    float3  vv = cross(uu, n);

    float ra = sqrt(r.y);
    float rx = ra * cos(6.2831 * r.x);
    float ry = ra * sin(6.2831 * r.x);
    float rz = sqrt(1.0 - r.y);
    float3  rr = float3(rx * uu + ry * vv + rz * n);

    return normalize(rr);
}


float3 randomSphereDirection(inout float seed) {
    float2 h = hash2(seed) * float2(2., 6.28318530718) - float2(1, 0);
    float phi = h.y;
    return float3(sqrt(1. - h.x * h.x) * float2 (sin(phi), cos(phi)), h.x);
}


float3 sampleLight(const in float3 ro, inout float seed) {
    float3 n = randomSphereDirection(seed) * g_sceneCB.lightSphere.w;
    return g_sceneCB.lightSphere.xyz + n;
}




float3x3 GetTangentSpace(float3 normal)
{
    // Choose a helper vector for the cross product
    float3 helper = float3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
        helper = float3(0, 0, 1);
    // Generate vectors
    float3 tangent = normalize(cross(normal, helper));
    float3 binormal = normalize(cross(normal, tangent));
    return float3x3(tangent, binormal, normal);
}



float3 SampleHemisphere(float3 normal, inout float seed)
{
    // Uniformly sample hemisphere direction
    float cosTheta = rand_ik(seed);
    float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));
    float phi = 2 * PI * rand_ik(seed);
    float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
    // Transform direction to world space
    return mul(tangentSpaceDir, GetTangentSpace(normal));
}




float orenNayar(float3 v, float3 light, float3 normal, float roughness) {

    float roughness2 = roughness * roughness;
    float2 oren_nayar_fraction = roughness2 / (roughness2 + float2(0.33, 0.09));
    float2 oren_nayar = float2(1, 0) + float2(-0.5, 0.45) * oren_nayar_fraction;

    float2 cos_theta = saturate(float2(dot(normal, light), dot(normal, v)));
    float2 cos_theta2 = cos_theta * cos_theta;
    float sin_theta = sqrt((1 - cos_theta2.x) * (1 - cos_theta2.y));
    float3 light_plane = normalize(light - cos_theta.x * normal);
    float3 view_plane = normalize(v - cos_theta.y * normal);
    float cos_phi = saturate(dot(light_plane, view_plane));

    float diffuse_oren_nayar = cos_phi * sin_theta / max(cos_theta.x, cos_theta.y);
    float diffuse = cos_theta.x * (oren_nayar.x + oren_nayar.y * diffuse_oren_nayar);

    return diffuse;
}


float Fresnel(float3 wi, float3 normal, float3 eta) {
    float cosIncident = clamp(-1, 1, dot(wi, normal));
    float etaI = 1, etaT = eta;
    if (cosIncident > 0) {
        float temp = etaT;
        etaT = etaI;
        etaI = temp;
    }

    float sinT = etaI / etaT * sqrt(max(0.0f, 1 - cosIncident * cosIncident));

    if (sinT >= 1) {

        //total internal reflection, return probability of reflection = 1
        return 1;
    }
    else {
        float cosT = sqrt(max(0.0f, 1 - sinT * sinT));
        float cosI = abs(cosIncident);
        float Rs = ((etaT * cosI) - (etaI * cosT)) / ((etaT * cosI) + (etaI * cosT));
        float Rp = ((etaI * cosI) - (etaT * cosT)) / ((etaI * cosI) + (etaT * cosT));

        float fresn = (Rs * Rs + Rp * Rp) / 2;
        return fresn;
    }
}

float rand(in float2 uv) {
    float2 noise = (frac(sin(dot(uv, float2(12.9898, 78.233) * 2.0)) * 43758.5453));
    return abs(noise.x + noise.y) * 0.5;
}

float3 randomDirection(float2 ra) {
    float theta_0 = 2 * M_PI * rand(ra);
    float theta_1 = acos(1 - 2 * rand(ra));
    float3 dir = float3(sin(theta_0) * sin(theta_1), sin(theta_0)*cos(theta_1), sin(theta_1));
    return dir;
}



inline float3 SquareToDiskConcentric(in float2 sample)
{
    // Used Peter Shirley's concentric disk warp
    float radius;
    float angle;
    float a = (2 * sample[0]) - 1;
    float b = (2 * sample[1]) - 1;

    if (a > -b) {
        if (a > b) {
            radius = a;
            angle = (PI / 4.f) * (b / a);
        }
        else {
            radius = b;
            angle = (PI / 4.f) * (2 - (a / b));
        }
    }
    else {
        if (a < b) {
            radius = -a;
            angle = (PI / 4.f) * (4 + (b / a));
        }
        else {
            radius = -b;
            if (b != 0) {
                angle = (PI / 4.f) * (6 - (a / b));
            }
            else {
                angle = 0;
            }
        }
    }
    return float3(radius * cos(angle), radius * sin(angle), 0);
}

inline float3 SquareToHemisphereCosine(in float2 sample)
{
    // Used Peter Shirley's cosine hemisphere
    float3 disk = SquareToDiskConcentric(sample);
    return float3(disk[0], disk[1], sqrt(1.f - pow(length(disk), 2.f)));
}


inline float AbsCosTheta(in float3 w) {
    return abs(w.z);
}

inline bool SameHemisphere(in float3 w, in float3 wp) {
    return w.z * wp.z > 0;
}

inline float3 Lambert_Sample_f(in float3 wo, out float3 wi, in float2 samplePt, out float pdf, in float3 albedo) {
    wi = SquareToHemisphereCosine(samplePt);
    if (wo.z < 0) wi.z *= -1;
    wi = normalize(wi);
    pdf = SameHemisphere(wo, wi) ? INV_PI * AbsCosTheta(wi) : 0;

    return INV_PI * albedo;
}

float reflectionBRDF(float3 incomingDirection, float3 normal) {
    float3 n_in = normalize(-incomingDirection);
    float3 outgoing = reflect(n_in, normal);

    float thetaI = atan(n_in.y / n_in.x);
    float phiI = acos(n_in.z);


    float thetaO = atan(outgoing.y / outgoing.x);
    float phiO = acos(outgoing.z);

    float f_rs = 2 * (sin(thetaO) * sin(thetaO) - sin(thetaI) * sin(thetaI)) * (phiO - phiI);
    return f_rs;
}

float FresnelAmount(float n1, float n2, float3 normal, float3 incident) {
    float r0 = (n1 - n2) / (n1 + n2);
    r0 *= r0;
    float cosx = -dot(normal, incident);
    if (n1 > n2) {
        float n = n1 / n2;
        float sint = n * n*(1.0f - cosx * cosx);

        if (sint > 1.0) {
            return 1.0;
        }
        cosx = sqrt(1.0 - sint);
    }
    float x = 1.0 - cosx;
    float ret = r0 + (1.0f - r0) * x * x * x * x * x;
    ret = (l_materialCB.reflectanceCoef + (1.0 - l_materialCB.reflectanceCoef) * ret);
    return ret;
}


float PhongLighting(float3 normal, bool shadowHit) {
    float3 position = HitWorldPosition();
    float3 lightDir = normalize(g_sceneCB.lightPosition.xyz - position);
    float3 viewDir = normalize(-WorldRayDirection());
    float3 refl = normalize(reflect(normal, lightDir));
    float illum;
    if (l_materialCB.refractiveCoef == 0) {
         illum = l_materialCB.diffuseCoef * saturate(dot(lightDir, normal));

        illum += l_materialCB.specularCoef * pow(saturate(dot(refl,viewDir)), l_materialCB.specularPower);
    }
    else {
        illum = l_materialCB.specularCoef * pow(saturate(dot(refl, viewDir)), l_materialCB.specularPower);

    }
    if (!shadowHit) {

    }
    else {
       //llum = 0;

    }
    return illum;
}

bool refractTest(float3 v, float3 normal, float index, inout float3 refracted) {
    float dt = dot(v, normal);
    float discriminant = 1.0 - index * index * (1 - dt * dt);
    if (discriminant > 0) {
        refracted = index * (v - normal * dt) - normal * sqrt(discriminant);
        return true;
    }
    else {
        return false;
    }
}

PhotonPayload TracePhotonRay(in Ray ray, in PhotonPayload payload) {
    if (payload.recursionDepth >= MAX_RAY_RECURSION_DEPTH) {
        return payload;
    }

    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    // Set TMin to a zero value to avoid aliasing artifacts along contact areas.
    // Note: make sure to enable face culling so as to avoid surface face fighting.
    rayDesc.TMin = 0.01;
    rayDesc.TMax = 10000;

    payload.recursionDepth += 1;

    TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Radiance],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Radiance],
        rayDesc, payload);

    return payload;
}

// Trace a radiance ray into the scene and returns a shaded color.
RayPayload TraceRadianceRay(in Ray ray, in RayPayload payload)
{
    if (payload.recursionDepth >= MAX_RAY_RECURSION_DEPTH)
    {
       payload.color = float4(1,1,1, 1);
       return payload;
    }

    // Set the ray's extents.
    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    // Set TMin to a zero value to avoid aliasing artifacts along contact areas.
    // Note: make sure to enable face culling so as to avoid surface face fighting.
    rayDesc.TMin = 0.01;
    rayDesc.TMax = 10000;
  
    payload.recursionDepth += 1;

    TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Radiance],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Radiance],
        rayDesc, payload);

    return payload;
}



bool ShadowRay(in Ray ray, in UINT currentRayRecursionDepth) {

    if (currentRayRecursionDepth >= MAX_RAY_RECURSION_DEPTH)
    {
        return false;
    }


    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    rayDesc.TMin = 0.1;
    rayDesc.TMax = 10000;

    ShadowRayPayload shadow = { true };

    TraceRay(g_scene,
        RAY_FLAG_CULL_BACK_FACING_TRIANGLES
                   // ~skip any hit shaders
        | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Shadow],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Shadow],
        rayDesc, shadow);

    return shadow.hit;
}

inline void GetPixelPosition(float3 rayHitPosition, float2 screenDim, out uint2 pixelIndex, out bool inRange)
{
    float4 clippingCoord = mul(float4(rayHitPosition, 1), g_sceneCB.projection);
    clippingCoord.xyz /= clippingCoord.w;

    if (clippingCoord.z < 0.01f || clippingCoord.z > 1 || clippingCoord.x < -1 || clippingCoord.x > 1 || clippingCoord.y < -1 || clippingCoord.y > 1) {
        inRange = false;
        return;
    }

    inRange = true;
    pixelIndex.x = ((clippingCoord.x + 1.0) * 0.5f) * screenDim.x;
    pixelIndex.y = ((1.0 - clippingCoord.y) * 0.5f) * screenDim.y;
}



uint wang_hasher(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}
uint wang_hash(uint seed, int x , int y)
{
    seed = seed + 76.897898 * 48.789789 * cos(x) * sin(y) * 20.79797;
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}
float chessBoard(float3 pos) {

    float chess = floor(sqrt(pos.x * pos.x + pos.z * pos.z)) + floor(atan(pos.z / pos.x));
    chess = floor(pos.x + 0.1); //+ floor(pos.z);
    chess = frac(chess * 0.5);
    chess *= 2;
    if (chess == 0.0) {
        chess = 0.5;
    }
    return chess;
}

float3 getColour(float3 nDir) {
    float3 dir = normalize(WorldRayDirection());
    float t = 0.5 * (dir.y + 1.0);
    return (1.0 - t) * float3(1.0, 1.0, 1.0) + t * float3(0.52941176471, 0.80784313725, 0.98039215686);
}

inline void VisualizePhotonBuffer(float2 screenDims)
{
    // Get the Hit location of the photon
    for (int i = 0; i < 100; i++) {
        float3 hitPosition = photonBuffer[i].position.xyz;

        // Find the Screen Space Coord for the photon
        uint2 pixelPos;
        bool inRange;

        GetPixelPosition(hitPosition, screenDims, pixelPos, inRange);

        if (!inRange) {
            return;
        }

        // Shadow Ray.
        RayDesc ray;
        ray.Origin = hitPosition;
        //ray.Direction = normalize(g_sceneCB.cameraPosition.xyz - hitPosition);
        ray.Direction = g_sceneCB.cameraPosition.xyz - hitPosition;
        ray.TMin = 0.001;
        ray.TMax = 1.001;

        Ray r = { hitPosition, g_sceneCB.cameraPosition.xyz - hitPosition };
        ShadowRayPayload shadow = { true };


        TraceRay(g_scene,
            RAY_FLAG_CULL_BACK_FACING_TRIANGLES
            // ~skip any hit shaders
            | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
            TraceRayParameters::InstanceMask,
            TraceRayParameters::HitGroup::Offset[RayType::Shadow],
            TraceRayParameters::HitGroup::GeometryStride,
            TraceRayParameters::MissShader::Offset[RayType::Shadow],
            ray, shadow);

        if (!shadow.hit) {
            float2 tempPixel = pixelPos;
            tempPixel /= screenDims;
            g_renderTarget[pixelPos] += float4(hitPosition, 0)*100;
        }
    }

}
inline void VisualizePhoton(float4 photon, float4 colour, float2 screenDims)
{
    // Get the Hit location of the photon
    float3 hitPosition = photon.xyz;

    // Find the Screen Space Coord for the photon
    uint2 pixelPos;
    bool inRange;
    GetPixelPosition(hitPosition, screenDims, pixelPos, inRange);

    if (!inRange) {
        return;
    }

    // Shadow Ray.
    RayDesc ray;
    ray.Origin = hitPosition;
    //ray.Direction = normalize(g_sceneCB.cameraPosition.xyz - hitPosition);
    ray.Direction = g_sceneCB.cameraPosition.xyz - hitPosition;
    ray.TMin = 0.001;
    ray.TMax = 1.001;

    Ray r = { hitPosition, g_sceneCB.cameraPosition.xyz - hitPosition };
    ShadowRayPayload shadow = { true };
   

    TraceRay(g_scene,
        RAY_FLAG_CULL_BACK_FACING_TRIANGLES
        // ~skip any hit shaders
        | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Shadow],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Shadow],
        ray, shadow);
    
    if (!shadow.hit) {
        float2 tempPixel = pixelPos;
        tempPixel /= screenDims;
        g_renderTarget[pixelPos] = colour*1000;
    }

}

inline void GetTileIndex(float3 rayHitPosition, out uint tileIndex) {

    uint width, height;
    g_renderTarget.GetDimensions(width, height);

    float2 screenDim = float2(width, height);

    uint2 pixelIndex;
    bool inRange;
    GetPixelPosition(rayHitPosition, screenDim, pixelIndex, inRange);

    //suppose a tile is 64*64 pixels
    //order tiles in the following way
    //|1|2|3|4|
    //|5|6|7|8|
    //|9|10...|
    //|. .
    //|.   .
    //|.     .

    //classify pixel index
}

[shader("raygeneration")]
void CompositeRayGen() {
    //add corresponding RTVs together.
    uint2 index = DispatchRaysIndex().xy;
    g_renderTarget[index] += g_rasterTarget[index];
   /* for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            uint2 i = uint2(dx, dy);
            g_renderTarget[index] += g_renderTarget[i];
        }
    }

    g_renderTarget[index] = normalize(g_renderTarget[index]);*/
   // g_renderTarget[index] += float4(1, 1, 0, 0);
    //g_rasterTarget[index] = float4(1, 1, 0, 0);
    //
  //  g_rasterTarget[index] = g_renderTarget[index];
    //g_renderTarget[index] += g_rasterTarget[index];

}

[shader("closesthit")]
void CompositeHit(inout RayPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr) {
    //add corresponding RTVs together.
}
[shader("miss")]
void CompositeMiss(inout RayPayload rayPayload) {
    //add corresponding RTVs together.
}
[shader("raygeneration")]
void Photon_Ray_Gen() {

    //g_renderTarget[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
  /* for (int i = 0; i < 6; i++) {
        screenSpacePhoton[i][DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
        screenSpacePhotonColour[i][DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
        screenSpacePhotonDirection[i][DispatchRaysIndex().xy] = float4(0, 0, 0, 0);

    }*/
  //  photonBufferCounter.Store(0, 0);
    //AllMemoryBarrierWithGroupSync();

    float accumulatedFrames = g_sceneCB.accumulatedFrames;
    //uint ran = uint(uint(samplePoint.x) * uint(1973) + uint(samplePoint.y) * uint(9277) + uint(g_sceneCB.accumulatedFrames) * uint(26699)) | uint(1);

        // float3 direction = randomDirection(DispatchRaysIndex().xy + i);
    float seed = DispatchRaysIndex().x + DispatchRaysIndex().y * 3.43121412313 + frac(1.12345314312 * g_sceneCB.frameNumber);
   

    float2 samplePoint = DispatchRaysIndex().xy;

  
    UINT currentRecursionDepth = 0;

 
    uint width, height;
    g_renderTarget.GetDimensions(width, height);
    float2 screenDims = float2(width, height);

    float power = 1/(width * height); //number of photons to be emitted

    PhotonPayload payload = { float4(0,0,0,0), g_sceneCB.lightDiffuseColor*2*INV_PI,
     power, 1, 0 };


    for (int i = 0; i < 1; i++) {
       // float3 direction = randomDirection(DispatchRaysIndex().xy + i);
        // = uint(wang_hash_original(samplePoint.x + i + DispatchRaysDimensions().x * samplePoint.y));

        rng_state = g_sceneCB.rand1 + accumulatedFrames;
        float2 rany = float2(rand_ik(rng_state), rand_ik(rng_state));

        float3 ro = randomSphereDirection(seed);
        float3 rd = cosWeightedRandomHemisphereDirection(ro, seed);

        ro = g_sceneCB.lightSphere.xyz - ro * g_sceneCB.lightSphere.w;       // float2 r = rand_xor(ran);
//        float2 randi = float2(wang_hash_original(ran), wang_hash_original(ran));
        float3 origin = ro;
        //float3 dir = normalize(SquareToSphereUniform(rany));

        Ray ray = { ro,rd };
       // float3 origin = g_sceneCB.lightPosition;
        //float3 dir = normalize(SquareToSphereUniform(rany));
      //  float2 rand = float2(rand_xorshift(), rand_xorshift());
       // float3 dir = normalize(SquareToSphereUniform(rand));

     //   float3 origin = g_sceneCB.lightPosition;

        //Ray ray = { origin, dir };
        /*RayDesc ray;
        ray.Origin = origin;
        ray.Direction = dir;
        ray.TMin = 0.001;
        ray.TMax = 10000.0;


       // Ray r = GenerateCameraRay(DispatchRaysIndex().xy, g_sceneCB.cameraPosition.xyz, g_sceneCB.projectionToWorld);
       */
        

        PhotonPayload traced = TracePhotonRay(ray, payload);
        //VisualizePhoton(traced.position, screenDims);
        //VisualizePhotonBuffer(screenDims);
        //VisualizePhotonBuffer(traced, screenDims);
       // VisualizePhoton(traced, screenDims);
    }

 
    // Write the raytraced color to the output texture.
  //  g_renderTarget[DispatchRaysIndex().xy] = traced.color;
    //send random ray light source
   // g_renderTarget[DispatchRaysIndex().xy] = float4(0, 1, 0, 1);

}
 inline float maxValue(in float3 w) {
    return max(w.x, max(w.y, w.z));
}

inline bool inscreenSpace(float3 intersection, float2 uv) {
    uint width, height;
    g_renderTarget.GetDimensions(width, height);

    float2 screenDims = float2(width, height);

    bool inRange;
    GetPixelPosition(intersection, screenDims, uv, inRange);

    if (inRange) {
        return true;
    }
    return false;
}

[shader("miss")]
void Photon_Miss(inout PhotonPayload payload) {
    //g_renderTarget[DispatchRaysIndex().xy] = BackgroundColor;

}

[shader("miss")]
void Photon_Shadow_Miss(inout ShadowRayPayload payload) {
    payload.hit = false;
}


[shader("closesthit")]
void ClosestHit_Photon_Triangle(inout PhotonPayload payload, in BuiltInTriangleIntersectionAttributes attr) {

    float3 pos = HitWorldPosition();

    uint indexSizeInBytes = 4;
    uint indicesPerTriangle = 3;
    uint triangleIndexStride = indicesPerTriangle * indexSizeInBytes;
    uint baseIndex = PrimitiveIndex() * triangleIndexStride;
    uint index = InstanceID();
    // Load up three 16 bit indices for the triangle.
    const uint3 indices = Load3x16BitIndices(baseIndex, g_indices);

    // Retrieve corresponding vertex normals for the triangle vertices.
    float3 triangleNormals[3] = { g_vertices[indices[0]].normal,
                                   g_vertices[indices[1]].normal,
                                    g_vertices[indices[2]].normal
    };

    float raySize = sqrt(dot(pos - WorldRayOrigin(), pos - WorldRayOrigin()));
    float3 normal = HitAttribute(triangleNormals, attr.barycentrics);
    


    //compute cosine 
    float3 colour = payload.colour * l_materialCB.albedo;
    payload.colour = float4(colour, 1);
    float3 dir = normalize(WorldRayDirection());

    //compute path probability
    
    //if diffuse surface, store photon
    if (l_materialCB.reflectanceCoef <= 0.0f && l_materialCB.refractiveCoef <= 0 && payload.recursionDepth > 1) {

    
        uint dstIndex = photonBuffer.IncrementCounter();
        Photon p = { float4(pos, raySize), float4(dir, 1), float4(colour, 1), float4(0, 1, 0, payload.probability)};

        if (dstIndex < PHOTON_COUNT) {
            photonBuffer[dstIndex] = p;
        }
        else {
           uint decr =  photonBuffer.DecrementCounter();
           return;

        }

    }

    float3 refractPos;
    float3 reflectPos;

    float maximumPower = maxValue(payload.colour);
  //  if (rand_xorshift() < (1.f - maximumPower)) {
    //    return;
    //}
    if (l_materialCB.refractiveCoef > 0) {
        //assume refractive glass
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, normal) > 0) {
            outwardNormal = -normal;
            index = n2;
        }
        else {
            outwardNormal = normal;
            index = n1 / n2;
        }
        if (refractTest(dir, outwardNormal, index, refracted)) {
            Ray r = { pos, refracted };
            refractPos =  TracePhotonRay(r, payload).position;
        }
        else {
            Ray r = { pos, reflect(dir, normal) };
            TracePhotonRay(r, payload);
            // refractionColour = TraceRadianceRay(r, rayPayload.recursionDepth);
        }
        float reflectMulti = FresnelAmount(n1, n2, normal, dir);
    }


    if (l_materialCB.reflectanceCoef > 0.1f) {
        Ray r = { pos, reflect(dir, normal) };
        //power of reflected photon should be scaled by the reflective property.
        payload.colour *= l_materialCB.reflectanceCoef;
        reflectPos = TracePhotonRay(r, payload).position;
    }
    else {
        float3 randDir = SampleHemisphere(normal, rng_state);
        Ray r = { pos, randDir };
        TracePhotonRay(r, payload);
    }
}

//don't need to define custom interesctions, since we will use the same as backward ray-tracing
[shader("closesthit")]
void ClosestHit_Photon_Procedural(inout PhotonPayload payload, in ProceduralPrimitiveAttributes attr) {
    //payload.colour = l_materialCB.albedo;

    float3 pos = HitWorldPosition();

    float3 dir = normalize(WorldRayDirection());
    float3 refractPos;
    float3 reflectPos;
    //payload.colour = l_materialCB.albedo;
    float3 colour = l_materialCB.albedo.xyz*payload.colour.xyz;
    payload.colour = float4(colour, 1);

    if (l_materialCB.reflectanceCoef <= 0.0f && l_materialCB.refractiveCoef <= 0 && payload.recursionDepth >= 1) {

        uint dstIndex = photonBuffer.IncrementCounter();
        float raySize = sqrt(dot(pos - WorldRayOrigin(), pos - WorldRayOrigin()));

        Photon p = { float4(pos, raySize), float4(dir, 1), float4(colour, 1), float4(attr.normal, payload.probability) };
        if (dstIndex < PHOTON_COUNT) {
            photonBuffer[dstIndex] = p;
        }
        else {
            uint decr = photonBuffer.DecrementCounter();
            return;

        }
    }

    //russian roulette
    float maximumPower = maxValue(payload.colour);
    //  if (rand_xorshift() < (1.f - maximumPower)) {
      //    return;
      //}

    if (l_materialCB.reflectanceCoef > 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        Ray r = { pos, reflect(dir, attr.normal) };
        reflectPos = TracePhotonRay(r, payload).position;
    }
    else if (l_materialCB.refractiveCoef > 0.0f) {
        float fresnel = Fresnel(dir, attr.normal, l_materialCB.refractiveCoef);
        bool outside = dot(dir, attr.normal) < 0 ? false : true;
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, attr.normal) > 0) {
            outwardNormal = -attr.normal;
            index = n2;
        }
        else {
            outwardNormal = attr.normal;
            index = n1 / n2;
        }
        refractTest(dir, outwardNormal, index, refracted);
        if (fresnel < 1) {

            Ray r = { pos, refracted };
            float temp = payload.probability;
            payload.probability =  (1 - fresnel);

            refractPos = TracePhotonRay(r, payload).position;
            payload.probability = temp;
            //setup refracted ray

        }

        float3 reflected = normalize(reflect(dir, attr.normal));
        Ray r = { pos, reflected };
        payload.probability = (fresnel);
        refractPos = TracePhotonRay(r, payload).position;

        //hitColour += reflectionColour * fresnel + refractColour * (1 - fresnel);
    }
    else {
        float3 randDir = SampleHemisphere(attr.normal, rng_state);
        payload.probability = INV_PI;
        Ray r = { pos, randDir };
        TracePhotonRay(r, payload);
    }
}

   


PathTracingPayload TraceForwardPath(in Ray ray, in PathTracingPayload payload)
{
  

    if (payload.recursionDepth >= MAX_RAY_RECURSION_DEPTH) {
        return payload;
    }
    // Set the ray's extents.
    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    // Set TMin to a zero value to avoid aliasing artifacts along contact areas.
    // Note: make sure to enable face culling so as to avoid surface face fighting.
    rayDesc.TMin = 0.01;
    rayDesc.TMax = 10000;

    payload.recursionDepth += 1;

        //need to generate a new seed given the current seed.

        //payload from intersection returns ray direction information, etc.

        //this is a bounce loop, so we're solving the intergral of the rendering equation

        //do some russian roulette
        //p = 1 - hemispherical reflectance of the material of the surface

        //diffuse = integral(emmisive*BRDF(surface point x, incoming, outgoing)*Visibility(x, y) - whether point y is visibile from point x
        //if the random bouncing ends up hitting the light, then the sample needs to be discared - this will never happen since we have a point light
        TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
            TraceRayParameters::InstanceMask,
            TraceRayParameters::HitGroup::Offset[RayType::Radiance],
            TraceRayParameters::HitGroup::GeometryStride,
            TraceRayParameters::MissShader::Offset[RayType::Radiance],
            rayDesc, payload);
    

    return payload;
}



// "GPU Random Numbers via the Tiny Encryption Algorithm"
uint tea(uint val0, uint val1)
{
    uint v0 = val0;
    uint v1 = val1;
    uint s0 = 0;

    for (uint n = 0; n < 16; n++)
    {
        s0 += 0x9e3779b9;
        v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
        v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
    }

    return v0;
}


uint wang_hash_original(uint seed)
{
    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}
float RandomFloat01(inout uint state)
{
    return float(wang_hash_original(state)) / 4294967296.0;
}

float3 RandomUnitVector(inout uint state)
{
    float z = RandomFloat01(state) * 2.0f - 1.0f;
    float a = RandomFloat01(state) * TWO_PI;
    float r = sqrt(1.0f - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return float3(x, y, z);
}


// Generate a random unsigned int in [0, 2^24) given the previous RNG state
// using the Numerical Recipes linear congruential generator
uint lcg(inout uint prev)
{
    uint LCG_A = 1664525u;
    uint LCG_C = 1013904223u;
    prev = (LCG_A * prev + LCG_C);
    return prev & 0x00FFFFFF;
}

// Generate a random float in [0, 1) given the previous RNG state
float rando(inout uint prev)
{
    return (float(lcg(prev)) / float(0x01000000));
}
float reseed(inout uint seed) {
    float r = wang_hasher(seed) * (1.0 / 4294967296.0);
    seed += 2000;
    return r;
}

float InterleavedGradientNoise(float2 xy) {
    return frac(52.9829189f
        * frac(xy.x * 0.06711056f
            + xy.y * 0.00583715f));
}


float3 TraceForwardPaths(Ray r, PathTracingPayload p) {
    float3 totalColour = float3(0, 0, 0);
    float3 energy = float3(1, 1, 1);
    float3 origin = r.origin;
    float3 direction = r.direction;
    int jdff = 0;
    p.energy = energy;
    while(p.recursionDepth < MAX_RAY_RECURSION_DEPTH){
        //totalColour += p.colour;

        RayDesc ray;
        ray.Origin = origin;
        ray.Direction = direction;
        ray.TMin = 0.01;
        ray.TMax = 10000;

        p.weight = jdff;
        TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
            TraceRayParameters::InstanceMask,
            TraceRayParameters::HitGroup::Offset[RayType::Radiance],
            TraceRayParameters::HitGroup::GeometryStride,
            TraceRayParameters::MissShader::Offset[RayType::Radiance],
            ray, p);
        
        origin = p.pos;
        direction = p.dir;
        p.recursionDepth++;
    }
    return totalColour;
}

[shader("raygeneration")]
void ForwardPathTracingRayGen() {
    float2 samplePoint = DispatchRaysIndex().xy;
    uint spp = g_sceneCB.spp;

    float2 screenDims = DispatchRaysDimensions().xy;

    uint accumulatedFrames = g_sceneCB.accumulatedFrames;
   
    UINT currentRecursionDepth = 0;
    float3 radiance = 0.0f;
    if (accumulatedFrames == 0) {
        spp = 4;
    }
    uint ran = uint(uint(samplePoint.x) * uint(1973) + uint(samplePoint.y) * uint(9277) + uint(g_sceneCB.frameNumber) * uint(26699)) | uint(1);
    for (int i = 0; i < 1; i++) {

        float seed = g_sceneCB.rand1 + accumulatedFrames;
        float2 rany = float2(rand_ik(seed), rand_ik(seed));
        float2 screen_coord = float2(samplePoint) + rany ;

        //float3 r_4 = RandomUnitVector(ran);
        Ray r = GenerateCameraPath(screen_coord, g_sceneCB.cameraPosition.xyz, g_sceneCB.projectionToWorld);

        //set seed.
        PathTracingPayload payload = { float4(0,0,0,0), float3(1.0f, 1.0f, 1.0f), r.origin, r.direction, 1, 0,  0, seed };
         //radiance += TraceForwardPaths(r, payload);
        radiance +=  TraceForwardPath(r, payload).colour;
         //radiance = float3(0, 0, 0);
        //float3 otherrad = radiance * g_renderTarget[DispatchRaysIndex().xy].xyz;
        //radiance += otherrad;
       //g_renderTarget[DispatchRaysIndex().xy] = float4(rany, 0.0f, 1.0f);//float4(ri, r_2, r_3, 1.0f);

    }



   // float4 stagingColour = D
    radiance *= 1.0f / float(1);
    float4 stagingColour = staging[DispatchRaysIndex().xy];
    float3 averageRadiance = radiance;
    float3 previousRadiance = g_renderTarget[DispatchRaysIndex().xy];
    if (accumulatedFrames == 0) {
         averageRadiance = stagingColour.xyz;
    }
    else {
       float4 previousRadiance = g_renderTarget[DispatchRaysIndex().xy];
        averageRadiance = lerp(previousRadiance, stagingColour, 1.0f / (accumulatedFrames + 1.0f));
    }

    g_renderTarget[DispatchRaysIndex().xy] = float4(averageRadiance, 0);

    
   // averageRadiance = radiance;
   // averageRadiance = lerp(g_renderTarget[DispatchRaysIndex().xy], radiance, 1.0f / (accumulatedFrames + 1.0f));
   // g_renderTarget[DispatchRaysIndex().xy] = lightTracingPhotons[9][DispatchRaysIndex().xy];
    // g_renderTarget[DispatchRaysIndex().xy] = normalize(float4(accumulatedFrames, accumulatedFrames, accumulatedFrames, 0));
    //g_renderTarget[DispatchRaysIndex().xy] = float4(averageRadiance, 1.0f); //+ lightTracingPhotons[8][DispatchRaysIndex().xy];

}




uint labelBRDF() {
    if (l_materialCB.reflectanceCoef <= 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        return 0;
        //diffuse
    }
    else if (l_materialCB.reflectanceCoef >= 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        return 1;
        //reflective
    }
    else if (l_materialCB.refractiveCoef >= 0.0f) {
        return 2;
    }
    return 0;
}
/**
float3 sampleLights(float3 hitPos, float3 normal, uint brdfType) {
    uint numberOfLights = 1;
    float3 l_dir = normalize(g_sceneCB.lightPosition - hitPos);
    float3 light = 0.0f;
    //evaluate BRDF for surface * lightPower;
    float brdfValue = 0.0f;
    switch (brdfType) {
        case 0:
            brdfValue = lambertian(normal, hitPos);
            break;
        case 1:
            break;
        case 2:
            break;
    light = g_sceneCB.lightAmbientColor*brdfValue;
    return light;
}*/

float energy(float3 color)
{
    return dot(color, 1.0f / 3.0f);
}

float sdot(float3 x, float3 y, float f = 1.0f) {
    return saturate(dot(x, y) * f);
}

float3 phong_correct(float3 pos, float3 w_i, float3 normal, float alpha, inout float3 energy) {
    float3 ref = reflect(w_i, normal);
    
   // float specChance = energy(float3(1,1,1));
    float3 dir = SampleHemisphere(ref, alpha);
    float f = (alpha + 2) / (alpha + 1);
  //  float3 energy *= (1.0f / specChance) * float3(1,1,1) * sdot(normal, dir, f);
   // return (alpha + 2)/TWO_PI*(dot())
}

float SmoothnessToPhongAlpha(float s)
{
    return pow(1000.0f, s * s);
}

float getWeightForPath(int e, int l) {
    return float(e + l + 2);
}


float3 bidirectionalSummation(float3 origin, uint recursionDepth, float3 pointNormal, float3 energy, uint jdiff) {
    float2 threadID = DispatchRaysIndex().xy;

    float3 totalColour = float3(0, 0, 0);
    for (int i = 0; i < MAX_RAY_RECURSION_DEPTH; ++i) {
        //float3 direction = (lightTracingPhotons[i][threadID].xyz - origin);
       // float3 nDir = normalize(direction);
        //float3 normal = lightTracingNormals[i][threadID].xyz;
        //float4 colour = lightTracingColours[i][threadID];

       // Ray shadowRay = { origin, nDir };
        //bool checkLightVisible = ShadowRay(shadowRay, recursionDepth);
       // if (!checkLightVisible) {

            //float weight = saturate(dot(nDir, pointNormal)) * saturate(dot(-nDir, normal)) * saturate(1.0f / dot(direction, direction));
           // totalColour += colour.xyz * energy*weight;// weight/getWeightForPath(jdiff, i);
        //}
    }
   // totalColour = lightTracingPhotons[2+3][threadID].xyz;

    return totalColour;
}




float3 directionFromBRDF(float3 normal, inout uint seed) {
    uint brdf = labelBRDF();
    float3 dir;
    if (brdf == 0) {
        //random direction


        //sample the light
        dir = cosWeightedRandomHemisphereDirection(normal, seed);
        // Ray r = { pos, dir };
    }
    else if (brdf == 1) {
        dir = reflect(WorldRayDirection(), normal);
        //reflected direction
    }
    else {
        //sample refraction
        float fresnel = Fresnel(WorldRayDirection(), normal, l_materialCB.refractiveCoef);
        bool outside = dot(dir, normal) < 0 ? false : true;
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, normal) > 0) {
            outwardNormal = -normal;
            index = n2;
        }
        else {
            outwardNormal = normal;
            index = n1 / n2;
        }
        refractTest(dir, outwardNormal, index, refracted);

        return refracted;
     

        //refracted direction
    }

    return dir;
}


[shader("closesthit")]
void ForwardPathTracingClosestHitTriangle(inout PathTracingPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr) {

    float3 pos = HitWorldPosition();
    float3 normal = float3(0, 1, 0);
    float3 light_direction = (g_sceneCB.lightPosition - pos);
   // uint brdfType = labelBRDF();
    //sample lights
    Ray sr = { pos, light_direction };
    bool shadowHit = ShadowRay(sr, rayPayload.recursionDepth);

   
   
    float s = chessBoard(pos);
    //float3 c = float3(0.3, 0.3, 0.3);
    //float3 c = float3(1, 1, 1);
    float3 c = float3(0.6, 0.6, 0.6);
    //float3 c = float3(0.1, 0.01, 0.3)*s;
    //lambertf is the light value here
    float3 lambert = lambertian(normal, pos, c);

    if (rayPayload.recursionDepth == 1) {
        //direct lighting'
        for (int i = 0; i < MAX_RAY_RECURSION_DEPTH; i++) {
          //  lightTracingColours[i][DispatchRaysIndex().xy] *= float4(lambert, 0);
        }
       // g_renderTarget[DispatchRaysIndex().xy] *= float4(lambert, 0);
        //lightTracingPhotons[1][DispatchRaysIndex().xy].xyz *= lambert ;
    }
    //brdf already multiplied by L_i
    uint seed = rayPayload.randomSeed;

    rayPayload.colour = float4(lambert.xyz, 0);
    float3 r_sample = float3(0, 0, 0);
    //sample the light
    float3 r_dir = SampleHemisphere(normal, seed);
    rayPayload.randomSeed = seed;
    //float3 dir = normalize(normal + RandomUnitVector(seed));
    Ray r = { pos, r_dir };
    rayPayload.energy *= 2 * c * sdot(normal, r_dir);

    r_sample = TraceForwardPath(r, rayPayload).colour;
    if (shadowHit) {
        lambert *= 0.2;
    }


    rayPayload.colour = float4(lambert, 0) + float4(rayPayload.energy*r_sample, 0);
    //rayPayload.colour +=float4(rayPayload.energy*lambert, 0);
    //sammple the hemisphere of the BRDF and connect it to the light
    //we have hit a triangle
    

    //want to connect this path to the light, evaluate radiance
    //L(x ,w ) = L_e(x, w) + L_dir(x, w) + L_indir(x, w)
   

}

[shader("closesthit")]

void ForwardPathTracingClosestHitProcedural(inout PathTracingPayload rayPayload, in ProceduralPrimitiveAttributes attr) {
    //want to connect this path to the light, evaluate radiance
    float3 pos = HitWorldPosition();
    float3 normal = attr.normal;
    uint brdf = labelBRDF();

    float4 reflectiveColour = float4(0, 0, 0, 0);
    float4 hitColour = float4(0, 0, 0, 0);
    float3 lambert = float3(0, 0, 0);
    float3 monte_sample = float3(0, 0, 0);

    
    //uint seed = rayPayload.seed
    //float3 n_direction = SampleHemisphere()
    if (brdf == 0) {
        //sample light source
        lambert = lambertian(normal, pos, l_materialCB.albedo);

        //setup random ray, and trace
        uint seed = rayPayload.randomSeed;

        //sample the light
        float3 dir = normalize(normal + RandomUnitVector(seed));
        Ray r = { pos, dir };
        rayPayload.randomSeed = seed;

        rayPayload.energy *= 2 * l_materialCB.albedo * sdot(normal, dir);
        monte_sample = TraceForwardPath(r, rayPayload).colour;
    }
    else if (brdf == 1) {
       
        float alpha = 300;
        float3 specular = 0.4f;
        float3 s = min(1.0f - specular, l_materialCB.albedo);
        float specChance = energy(specular);
        float diffChance = energy(s);

        float sum = specChance + diffChance;
        specChance /= sum;
        diffChance /= sum;
        uint seed = rayPayload.randomSeed;
        float roulette = rand_ik(seed);
        rayPayload.randomSeed = seed;
        if (roulette < specChance) {
            float3 direction = reflect(WorldRayDirection(), normal);
            rayPayload.energy *= (1.0f / specChance) * specular * sdot(normal, direction);

            Ray r = { pos, direction };
            reflectiveColour = TraceForwardPath(r, rayPayload).colour;
        }
        else {
            uint seed = rayPayload.randomSeed;
            float3 dir = SampleHemisphere(normal, seed);
            rayPayload.randomSeed = seed;
            rayPayload.energy *= (1.0f / diffChance) * s * sdot(normal, dir);
            Ray r = { pos, dir };
            reflectiveColour = TraceForwardPath(r, rayPayload).colour;
        }
     
    }else if(brdf == 2){
            float3 dir = WorldRayDirection();

            float4 refractColour;
            float4 reflectionColour;
            //sample refraction
            float fresnel = Fresnel(dir, attr.normal, l_materialCB.refractiveCoef);
            bool outside = dot(dir, attr.normal) < 0 ? false : true;
            float n1 = 1;
            float n2 = l_materialCB.refractiveCoef;
            float3 outwardNormal;
            float index;
            float3 refracted;
            if (dot(dir, attr.normal) > 0) {
                outwardNormal = -attr.normal;
                index = n2;
            }
            else {
                outwardNormal = attr.normal;
                index = n1 / n2;
            }
            refractTest(dir, outwardNormal, index, refracted);
            if (fresnel < 1) {

                Ray r = { pos, refracted };
                refractColour = TraceForwardPath(r, rayPayload).colour;
                //setup refracted ray

            }

            float3 reflected = normalize(reflect(dir, attr.normal));
            Ray r = { pos, reflected };
            reflectionColour = TraceForwardPath(r, rayPayload).colour;

            hitColour += reflectionColour * fresnel + refractColour * (1 - fresnel) + l_materialCB.albedo;

            //hitColour += l_materialCB.albedo;

    }
    
    rayPayload.colour = float4(float4(rayPayload.energy, 0)* (reflectiveColour.xyz + hitColour.xyz  + monte_sample) + lambert , 0);
}

[shader("miss")]

void MissPathTracing(inout PathTracingPayload rayPayload) {
    float3 ndir = normalize(WorldRayDirection());
    rayPayload.energy = 0.0f; 
    rayPayload.recursionDepth = MAX_RAY_RECURSION_DEPTH;
    //rayPayload.colour = float4(getColour(ndir), 0);
}




float rand_xorshift()
{
    // Xorshift algorithm from George Marsaglia's paper
    rng_state ^= uint(rng_state << 13);
    rng_state ^= uint(rng_state >> 17);
    rng_state ^= uint(rng_state << 5);
    return rng_state * prng_01_convert;
}

inline float3 calculateRandomDirectionInHemisphere(in float3 normal) {

    float up = sqrt(rand_xorshift()); // cos(theta)
    float over = sqrt(1 - up * up); // sin(theta)
    float around = rand_xorshift() * TWO_PI;

    // Find a direction that is not the normal based off of whether or not the
    // normal's components are all equal to sqrt(1/3) or whether or not at
    // least one component is less than sqrt(1/3). Learned this trick from
    // Peter Kutz.

    float3 directionNotNormal;
    if (abs(normal.x) < SQRT_OF_ONE_THIRD) {
        directionNotNormal = float3(1, 0, 0);
    }
    else if (abs(normal.y) < SQRT_OF_ONE_THIRD) {
        directionNotNormal = float3(0, 1, 0);
    }
    else {
        directionNotNormal = float3(0, 0, 1);
    }

    // Use not-normal direction to generate two perpendicular directions
    float3 perpendicularDirection1 =
        normalize(cross(normal, directionNotNormal));
    float3 perpendicularDirection2 =
        normalize(cross(normal, perpendicularDirection1));

    return up * normal
        + cos(around) * over * perpendicularDirection1
        + sin(around) * over * perpendicularDirection2;
}
inline float3 SquareToSphereUniform(float2 samplePoint)
{
    float radius = 1.f;

    float phi = samplePoint.y * PI;
    float theta = samplePoint.x * TWO_PI;

    float3 result;
    result.x = radius * cos(theta) * sin(phi);
    result.y = radius * cos(phi);
    result.z = radius * sin(theta) * sin(phi);
    return result;
}


void lightPath(inout float seed) {
    // float2 r = rand_xor(ran);
    //float2 rany = float2(rand_ik(seed), rand_ik(seed));
    float2 random = float2(rand_xorshift(), rand_xorshift());
    float3 dir = SquareToSphereUniform(random);
    float3 ro = randomSphereDirection(seed);
   // float3 rd = cosWeightedRandomHemisphereDirection(ro, seed);

    ro = g_sceneCB.lightSphere.xyz + ro * g_sceneCB.lightSphere.w;
   // float3 origin = g_sceneCB.lightPosition;
   // float3 dir = normalize(SquareToSphereUniform(rany));
    PathTracingPayload p = { g_sceneCB.lightDiffuseColor*200, float3(0,0,0), ro, dir, 1, 0, 0, seed };
   while(p.recursionDepth <= MAX_RAY_RECURSION_DEPTH){
        float3 normal;
        //ntersect scene
        RayDesc rayDesc;
        rayDesc.Origin = ro;
        rayDesc.Direction = dir;
        rayDesc.TMin = 0.1;
        rayDesc.TMax = 10000;

        TraceRay(g_scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
            TraceRayParameters::InstanceMask,
            TraceRayParameters::HitGroup::Offset[RayType::Radiance],
            TraceRayParameters::HitGroup::GeometryStride,
            TraceRayParameters::MissShader::Offset[RayType::Radiance],
            rayDesc, p);

  
        //lightTracingPhotons[1][g_index] = float4(p.dir, 0);
        //lightTracingPhotons[2][g_index] = float4(p.colour);

        //lightTracingPhotons[p.recursionDepth + 1][DispatchRaysIndex().xy] = float4(p.pos, 0);
        p.recursionDepth++;
        ro = p.pos;
        dir = p.dir;
    }
}


inline void VisualiseLightVertex(float4 photon, float4 colour, float4 w_i, float4 normal, float2 screenDims, float accumulatedFrames)
{
    // Get the Hit location of the photon
    float3 hitPosition = photon.xyz;
    uint brdf = (uint)photon.w;
    // Find the Screen Space Coord for the photon
    uint2 pixelPos;
    bool inRange;
    GetPixelPosition(hitPosition, screenDims, pixelPos, inRange);

    if (!inRange) {
        return;
    }

    // Shadow Ray.
    RayDesc ray;
    ray.Origin = hitPosition;
    //ray.Direction = normalize(g_sceneCB.cameraPosition.xyz - hitPosition);
    ray.Direction = g_sceneCB.cameraPosition.xyz - hitPosition;
    ray.TMin = 0.001;
    ray.TMax = 1.001;

    Ray r = { hitPosition, g_sceneCB.cameraPosition.xyz - hitPosition };
    ShadowRayPayload shadow = { true };


    TraceRay(g_scene,
        RAY_FLAG_CULL_BACK_FACING_TRIANGLES
        // ~skip any hit shaders
        | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER, // ~skip closest hit shaders,  
        TraceRayParameters::InstanceMask,
        TraceRayParameters::HitGroup::Offset[RayType::Shadow],
        TraceRayParameters::HitGroup::GeometryStride,
        TraceRayParameters::MissShader::Offset[RayType::Shadow],
        ray, shadow);

    if (!shadow.hit) {
        float2 tempPixel = pixelPos;
        tempPixel /= screenDims;

        float3 delta = photon.xyz - g_sceneCB.cameraPosition.xyz;
        float invSqrLength = 1 / dot(delta, delta);
        float3 nDelta = delta * sqrt(invSqrLength);
        
        //evaluate BRDF given w_i, and -nDelta.
        float3 nEye = normalize(-delta);
        float cos_alpha = abs(dot(nEye, normal));
        //convert to radiance
        float lambertian = 0.0f;
      
        //we give all photons initial flux, so we don't need to normalize (essentially cancels out)
        float conv = 1 / (4 * tan(90 / 2) * tan(45 / 2));
        //convert to radiance
        float4 radiance = colour * invSqrLength*cos_alpha;

        if (brdf == 0) {
            lambertian = INV_PI * abs(dot(normalize(w_i), normal));
            float pdf = INV_PI * abs(dot(nEye, normal));
            radiance *= lambertian/pdf;
        }
        else if (brdf == 1) {
            radiance *= 0.0f;
        }
        else {
            radiance *= 0.0f;

        }

        staging[pixelPos] += radiance;
       // g_renderTarget[pixelPos] += radiance;//
       // lightTracingPhotons[8][pixelPos] += colour;

        // else {
          //   g_renderTarget[pixelPos] = lerp(g_renderTarget[pixelPos], colour*conv, 1.0f / (accumulatedFrames + 1.0f));
         //}
    }


}


[shader("raygeneration")]
void LightTracingRayGen() {
    staging[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
    //first thing to do is construct light path
   // g_renderTarget[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
    float seed = DispatchRaysIndex().x + DispatchRaysIndex().y*3.43121412313 + frac(1.12345314312 * g_sceneCB.frameNumber);
    float2 screenDims = float2(DispatchRaysDimensions().x, DispatchRaysDimensions().y); 
   // g_renderTarget[DispatchRaysIndex().xy] = 0.0f;
    //g_renderTarget[DispatchRaysIndex().xy] = 0.0f;
    for (int j = 0; j < 4*MAX_RAY_RECURSION_DEPTH; j++) {
        
        lightTracingPhotons[j][DispatchRaysIndex().xy] = 0.0f;

        
        //lightTracingColours[i ][DispatchRaysIndex().xy] = 0.0f;
        //lightTracingNormals[i][DispatchRaysIndex().xy] = 0.0f;
    }
    uint accumulatedFrames = g_sceneCB.accumulatedFrames;
        rng_state = uint(wang_hash_original(DispatchRaysIndex().x + DispatchRaysDimensions().x * DispatchRaysIndex().y) + accumulatedFrames);

        //seed = DispatchRaysIndex().x + DispatchRaysIndex().y * 3.43121412313 + frac(1.12345314312 * accumulatedFrames)*g_sceneCB.rand1;
        lightPath(rng_state);

        float3 totalRadiance = 0.0f;
        for (int j = 0; j < MAX_RAY_RECURSION_DEPTH; j++) {
            uint c = j * 4;
            float4 pos = lightTracingPhotons[c][DispatchRaysIndex().xy];
            float4 colour = lightTracingPhotons[c + 1][DispatchRaysIndex().xy];
            float4 normal = lightTracingPhotons[c + 2][DispatchRaysIndex().xy];
            float4 dir = lightTracingPhotons[c + 3][DispatchRaysIndex().xy];

            // g_renderTarget[DispatchRaysIndex().xy] += float4(pos);
            VisualiseLightVertex(pos, colour, dir, normal, screenDims, g_sceneCB.accumulatedFrames);
            //g_renderTarget[DispatchRaysIndex().xy] = float4(1, 1, 0, 0);
        }

   


    //float3 ro = randomSphereDirection(seed);
    //float3 rd = cosWeightedRandomHemisphereDirection(ro, seed);
    //g_renderTarget[DispatchRaysIndex().xy] = float4(rds, 0);

    
    //create random sample on hemisphere
    //then trace

}


//SORT_FORCEINLINE float CosHemispherePdf(const Vector& v) {
  //  return absCosTheta(v) * INV_PI;
//}

[shader("closesthit")]
void LightTracingClosestHitTriangle(inout PathTracingPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr) {
    float3 normal = float3(0, 1, 0);
    float3 pos = HitWorldPosition();
    uint3 g_index = uint3(DispatchRaysIndex().xy, rayPayload.recursionDepth);
    float4 colour = rayPayload.colour;

    uint brdfType = labelBRDF();
    uint c = rayPayload.recursionDepth * 4;
    lightTracingPhotons[c][DispatchRaysIndex().xy] = float4(pos, float(brdfType));
    lightTracingPhotons[c + 1][DispatchRaysIndex().xy] = rayPayload.colour;
    lightTracingPhotons[c + 2][DispatchRaysIndex().xy] = float4(normal, 0);
    lightTracingPhotons[c+3][DispatchRaysIndex().xy] = float4(-WorldRayDirection(), 0);
    colour *= float4(0.8, 0.8, 0.8, 0);
    float lambertPdf = abs(dot(-WorldRayDirection(), normal)) * INV_PI;
   // colour /= lambertPdf;

    if (dot(WorldRayDirection(), normal) < 0.0f) {
       

    
       // lightTracingPhotons[rayPayload.recursionDepth][DispatchRaysIndex().xy] = float4(pos, 0);
        //lightTracingNormals[rayPayload.recursionDepth][DispatchRaysIndex().xy] = float4(normal, 0);
        //lightTracingColours[rayPayload.recursionDepth][DispatchRaysIndex().xy] = colour;
        //store
        //lightTracingPhotons[rayPayload.recursionDepth * 3][DispatchRaysIndex().xy] = float4(pos, 0);
       // lightTracingPhotons[rayPayload.recursionDepth * 3 + 1][DispatchRaysIndex().xy] = float4(normal, 0);
       // lightTracingPhotons[rayPayload.recursionDepth * 3 + 2][DispatchRaysIndex().xy] = colour;
        uint seed = rayPayload.randomSeed;

        float3 dir = normalize(normal + RandomUnitVector(seed));
        // Ray r = { pos, dir };
        float3 r = cosWeightedRandomHemisphereDirection(normal, seed);

        rayPayload.randomSeed = seed;
        rayPayload.dir = r;
        rayPayload.pos = pos;
        rayPayload.colour = colour;
    }
    else {
        rayPayload.recursionDepth = MAX_RAY_RECURSION_DEPTH;

    }
}


    //setup random ray, and trace
   


    //generate random diffuse ray
    

[shader("closesthit")]
void LightTracingClosestHitProcedural(inout PathTracingPayload rayPayload, in ProceduralPrimitiveAttributes attr) {
    float3 normal = attr.normal;
    float3 pos = HitWorldPosition();
    float4 colour = rayPayload.colour;
    uint3 g_index = uint3(DispatchRaysIndex().xy, rayPayload.recursionDepth);
    uint c = 4 * rayPayload.recursionDepth;
    uint brdf = labelBRDF();
    float fresnel = Fresnel(WorldRayDirection(), attr.normal, l_materialCB.refractiveCoef);
    if (brdf == 1) {
        colour *= fresnel;
    }
    else {
        colour *= (1 - fresnel);
    }
    colour *= l_materialCB.albedo;
 
    //then meant to the divide throughput or flux by the probability distribution for sampling the BRDF
    lightTracingPhotons[c][DispatchRaysIndex().xy] = float4(pos, brdf);
    lightTracingPhotons[c + 1][DispatchRaysIndex().xy] = rayPayload.colour;
    lightTracingPhotons[c + 2][DispatchRaysIndex().xy] = float4(normal, 0);
    lightTracingPhotons[c + 3][DispatchRaysIndex().xy] = float4(-WorldRayDirection(), 0);
  
 
    
   // lightTracingPhotons[rayPayload.recursionDepth * 3][DispatchRaysIndex().xy] = float4(pos, 0);
   // lightTracingPhotons[rayPayload.recursionDepth * 3 + 1][DispatchRaysIndex().xy] = float4(normal, 0);
   // lightTracingPhotons[rayPayload.recursionDepth * 3 + 2][DispatchRaysIndex().xy] = colour;

    if (dot(WorldRayDirection(), attr.normal)  < 0.0f) {

        uint seed = rayPayload.randomSeed;
        uint brdf = labelBRDF();

        if (brdf == 0) {


            float3 dir = normalize(normal + RandomUnitVector(seed));
            // Ray r = { pos, dir };
            float3 r = cosWeightedRandomHemisphereDirection(normal, seed);


          
              colour *= l_materialCB.albedo * INV_PI;
              colour *= abs(dot(attr.normal, r))/abs(dot(attr.normal, -WorldRayDirection()))*INV_PI;
                //lambertian brdf
            


            rayPayload.randomSeed = seed;
            rayPayload.dir = r;
            rayPayload.pos = pos;
            rayPayload.colour = colour;

            // lightTracingPhotons[rayPayload.recursionDepth][DispatchRaysIndex().xy] = float4(pos, 0);
             //lightTracingNormals[rayPayload.recursionDepth][DispatchRaysIndex().xy] = float4(normal, 0);
             //lightTracingColours[rayPayload.recursionDepth][DispatchRaysIndex().xy] = colour;

        }
        else {
       
            float3 dir = directionFromBRDF(normal, seed);
            rayPayload.pos = pos;
            rayPayload.dir = dir;
            rayPayload.randomSeed = seed;
            rayPayload.colour = colour;
           

        }
    }
    else {
        rayPayload.recursionDepth = MAX_RAY_RECURSION_DEPTH;
    }
}




//***************************************************************************
//********************------ Ray gen shader.. -------************************
//***************************************************************************
[shader("raygeneration")]
void MyRaygenShader()
{    
    g_renderTarget[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);

   // g_rasterTarget[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);

   // photonBufferCounter.Store(0, 0);

    //photonBuffer.DecrementCounter();
    float2 samplePoint = DispatchRaysIndex().xy;

    uint width;
    uint height;
    g_renderTarget.GetDimensions(width, height);
    float2 screenDims = float2(width, height);

    GBufferBRDF[DispatchRaysIndex().xy] = float4(0,0,0, 0);
    GBufferPosition[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);
    GBufferNormal[DispatchRaysIndex().xy] = float4(0, 0, 0, 0);


    /*  for (int i = 0; i < 100; i++) {
        Photon p = photonBuffer[i + DispatchRaysIndex().x + i*DispatchRaysIndex().y];
        VisualizePhoton(p.position, p.colour, screenDims);
    }*/

  /*  for (int i = 0; i < 6; i++) {
        float4 photon = screenSpacePhoton[i][samplePoint];
        float4 colour = screenSpacePhotonColour[i][samplePoint];
        VisualizePhoton(photon, colour, screenDims);
    }*/
       
   // VisualizePhotonBuffer( screenDims);

    rng_state = uint(wang_hash_original(samplePoint.x + DispatchRaysDimensions().x * samplePoint.y));

    UINT currentRecursionDepth = 0;
  Ray r = GenerateCameraRay(DispatchRaysIndex().xy, g_sceneCB.cameraPosition.xyz, g_sceneCB.projectionToWorld);
 //   Ray r = { ray.Origin, ray.Direction };
    RayPayload payload = { float4(0,0,0,0), 
        0,
        0 };
    //RayPayload traced = TraceRadianceRay(ray, payload);
    RayPayload traced = TraceRadianceRay(r, payload);

    // Write the raytraced color to the output texture.
    g_renderTarget[DispatchRaysIndex().xy] =  traced.color; //+ screenSpacePhotonMap[0][samplePoint];
    //uint offset = 0;

    //if drawing rays,   need to write the intersections for this ray into a 3D tensor.

}



//***************************************************************************
//******************------ Closest hit shaders -------***********************
//***************************************************************************

//implement a BRDF microfacet for the ground
[shader("closesthit")]
void MyClosestHitShader_Triangle(inout RayPayload rayPayload, in BuiltInTriangleIntersectionAttributes attr)
{
    uint indexSizeInBytes = 4;
    uint indicesPerTriangle = 3;
    uint triangleIndexStride = indicesPerTriangle * indexSizeInBytes;
    uint baseIndex = PrimitiveIndex() * triangleIndexStride;

    // Load up three 16 bit indices for the triangle.
    const uint3 indices = Load3x16BitIndices(baseIndex, g_indices);

    // Retrieve corresponding vertex normals for the triangle vertices.
    float3 triangleNormals[3] = { g_vertices[indices[0]].normal,
                                   g_vertices[indices[1]].normal,
                                    g_vertices[indices[2]].normal
    };

    float3 triangleNormal = HitAttribute(triangleNormals, attr.barycentrics);
    float4 ambient = l_materialCB.albedo;
    float3 hitPos = HitWorldPosition();
    float3 pos = HitWorldPosition();
    float3 dir = normalize(g_sceneCB.lightPosition.xyz - pos);
    float3 r_dir = randomDirection(HitWorldPosition().xy);
    float3 l_dir = g_sceneCB.lightPosition.xyz - hitPos;
    float3 pos_n =normalize(HitWorldPosition());

    uint depth = rayPayload.recursionDepth;

   
    float c = chessBoard(pos);

    Ray shadowRay;
    shadowRay.origin = HitWorldPosition();
    shadowRay.direction = dir;
    bool shadowHit = ShadowRay(shadowRay, rayPayload.recursionDepth);
    float3 normal = float3(0, 1, 0);
    float4 reflectionColour = float4(0, 0, 0, 0);
    
    float3 diffuseColour = float4(c, c, c, 0);

   
        //if immediate ray - i.e., recursion depth = 1
    if (rayPayload.recursionDepth == 1) {
        //store normal, and other elements in relevant GBuffer

        //for some reason the triangle normal is not working??! - for now just suppose n = (0, -1, 0)
        GBufferBRDF[DispatchRaysIndex().xy] = float4(diffuseColour, 1);
        GBufferPosition[DispatchRaysIndex().xy] = float4(pos, 0);
        GBufferNormal[DispatchRaysIndex().xy] = float4(0, 1, 0, 0);
    }

    if (shadowHit) {
        diffuseColour *= 0.5;
    }
   diffuseColour *= orenNayar(normalize(WorldRayDirection()), normal, normalize(l_dir), 1);
    



    
      if(l_materialCB.reflectanceCoef > 0){
        Ray r = { HitWorldPosition(), reflect(WorldRayDirection(), triangleNormal) };
        reflectionColour = TraceRadianceRay(r, rayPayload).color;

    }

    float4 color =  float4(diffuseColour.xyz, 0) + 0.15*reflectionColour;
    float t = RayTCurrent();
  //color = lerp(color, BackgroundColor, 1.0 - exp(-0.000002 * t * t * t));
    float3 colour;

    //rayPayload.color = color;
   // rayPayload.color = float4(colour, 0);
    float4 backColour = float4(getColour(normalize(WorldRayDirection())), 1);
    rayPayload.color = color;
    //rayPayload.color =  lerp(color, backColour, 1.0 - exp(-0.000002 * t * t * t)) + float4(colour, 0);

   // rayPayload.intersections[rayPayload.recursionDepth] = color;


}

//implement fresnel




[shader("closesthit")]
void MyClosestHitShader_AABB(inout RayPayload rayPayload, in ProceduralPrimitiveAttributes attr)
{   

    float3 pos = HitWorldPosition();
    float3 pos_n = normalize(HitWorldPosition());

    //intersectionBuffer[rayPayload.recursionDepth][DispatchRaysIndex().xy] = normalize(float4(pos, 1));
   
    //g_buffer[1080*y + x] = float4(pos, 1);
    float3 l_dir = normalize(g_sceneCB.lightPosition.xyz - pos);
    float4 reflectionColour = float4(0,0,0,1);
    Ray shadowRay = { pos, l_dir };
    float3 currentDir = RayTCurrent() * WorldRayDirection();
    currentDir += WorldRayOrigin();
    
    bool shadowHit = ShadowRay(shadowRay, rayPayload.recursionDepth);


    if (rayPayload.recursionDepth == 1) {
        //store normal, and other elements in relevant GBuffer
        float3 l = lambertian(attr.normal, pos, l_materialCB.albedo);
        GBufferBRDF[DispatchRaysIndex().xy] = float4(l, 0);
        GBufferPosition[DispatchRaysIndex().xy] = float4(pos, 0);
        GBufferNormal[DispatchRaysIndex().xy] = float4(attr.normal, 0);
    }

    float3 hitColour = float3(0, 0, 0);
    if (!shadowHit) {
        //ambient += 0.1*PhongLighting(float4(attr.normal, 0), shadowHit);
    }
    float3 dir = normalize(WorldRayDirection());
    float4 refractColour = float4(0, 0, 0, 0);
    if (l_materialCB.reflectanceCoef > 0.0f && l_materialCB.refractiveCoef <= 0.0f) {
        Ray r = { pos, reflect(dir, attr.normal) };
        reflectionColour = TraceRadianceRay(r, rayPayload).color;
        hitColour += reflectionColour;

    }
    else if (l_materialCB.refractiveCoef > 0.0f) {
        float fresnel = Fresnel(dir, attr.normal, l_materialCB.refractiveCoef);
        bool outside = dot(dir, attr.normal) < 0 ? false : true;
        float n1 = 1;
        float n2 = l_materialCB.refractiveCoef;
        float3 outwardNormal;
        float index;
        float3 refracted;
        if (dot(dir, attr.normal) > 0) {
            outwardNormal = -attr.normal;
            index = n2;
        }
        else {
            outwardNormal = attr.normal;
            index = n1 / n2;
        }
        refractTest(dir, outwardNormal, index, refracted);
        if (fresnel < 1) {

            Ray r = { pos, refracted };
            refractColour = TraceRadianceRay(r, rayPayload).color;
            //setup refracted ray
        
        }

        float3 reflected = normalize(reflect(dir, attr.normal));
        Ray r = { pos, reflected };
        reflectionColour = TraceRadianceRay(r, rayPayload).color;

        hitColour += reflectionColour * fresnel + refractColour * (1 - fresnel);
    }
    else {
        hitColour = l_materialCB.albedo * orenNayar(normalize(WorldRayDirection()), attr.normal, normalize(l_dir), 1);
       // hitColour =   lambertian(attr.normal, pos, l_materialCB.albedo);
    }
    float re = reflectionBRDF(dir, attr.normal);

//0.1f is a good coefficient for reflectioncolour.
 // rayPayload.color += refractionColour + 0.1*reflectionColour;
//  rayPayload.color = refractionColour;
float4 colour =  l_materialCB.albedo + float4(hitColour.xyz, 0);

//ray
//float3 sky = lerp(float3(0.52, 0.77, 1), float3(0.12, 0.43, 1), BackgroundColor.xyz);

float t = RayTCurrent();
float4 backColour = float4(getColour(normalize(WorldRayDirection())), 1);
//rayPayload.color = lerp(colour, backColour, 1.0 - exp(-0.000002 * t * t * t));
rayPayload.color = colour;
}

//***************************************************************************
//**********************------ Miss shaders -------**************************
//***************************************************************************



[shader("miss")]
void MyMissShader(inout RayPayload rayPayload)
{
   // float transition = pow(smoothstep(0.02, .5, d.y), 0.4);
//
    float3 ndir = normalize(WorldRayDirection());
   
    rayPayload.color = float4(getColour(ndir), 1);
   // float4 backgroundColor = float4(BackgroundColor);
    uint depth = rayPayload.recursionDepth;
    //float3 sky = lerp(float3(0.52, 0.77, 1), float3(0.12, 0.43, 1), BackgroundColor);
  //  rayPayload.color = BackgroundColor;
    //rayPayload.color =  float4(lerp(SkyColour.xyz, float3(0.4, 0.4, 0.4), float4(BackgroundColor)), 1);
    //g_renderTarget[DispatchRaysIndex().xy] = rayPayload.color;
   // intersectionBuffer[depth][DispatchRaysIndex().xy] = float4(0,0,0,0);

}

[shader("miss")]
void MyMissShader_ShadowRay(inout ShadowRayPayload rayPayload)
{


    rayPayload.hit = false;
}


//***************************************************************************
//**********************------ Any Hit Shaders -------**************************
//***************************************************************************
[shader("anyhit")]
void AnyHit_AnalyticPrimitive(inout RayPayload payload, in ProceduralPrimitiveAttributes attr) {
    //IgnoreHit();
    float3 pos = HitWorldPosition();
    if (l_materialCB.refractiveCoef > 0) {
        //  if(ShadowRay(payload)){}
         // payload.color = float4(1, 1, 0, 1);
         //IgnoreHit();
    }
    // payload.color = float4(1, 1, 0, 1);
}

[shader("anyhit")]
void AnyHit_Triangle(inout RayPayload payload, in BuiltInTriangleIntersectionAttributes attr) {
    // payload.color = float4(0, 0, 0, 1);
    //IgnoreHit();
}
//***************************************************************************
//*****************------ Intersection shaders-------************************
//***************************************************************************


[shader("closesthit")]
void ClosestHit_CSG( inout RayPayload payload, in ProceduralPrimitiveAttributes attr){

}
// Get ray in AABB's local space.
Ray GetRayInAABBPrimitiveLocalSpace()
{
    PrimitiveInstancePerFrameBuffer attr = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];

    // Retrieve a ray origin position and direction in bottom level AS space 
    // and transform them into the AABB primitive's local space.
    Ray ray;
    ray.origin = mul(float4(ObjectRayOrigin(), 1), attr.bottomLevelASToLocalSpace).xyz;
    ray.direction = mul(ObjectRayDirection(), (float3x3) attr.bottomLevelASToLocalSpace);
    return ray;
}

[shader("intersection")]
void MyIntersectionShader_AnalyticPrimitive()
{
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
    AnalyticPrimitive::Enum primitiveType = (AnalyticPrimitive::Enum) l_aabbCB.primitiveType;
   // AnalyticPrimitive::Enum primitiveType = AnalyticPrimitive::Enum::Plane;
    float thit;
    ProceduralPrimitiveAttributes attr;
    if (RayAnalyticGeometryIntersectionTest(localRay, primitiveType, thit, attr))
    {
        PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit, /*hitKind*/ 0, attr);
    }
}

[shader("intersection")]
void MyIntersectionShader_VolumetricPrimitive()
{
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
    VolumetricPrimitive::Enum primitiveType = (VolumetricPrimitive::Enum) l_aabbCB.primitiveType;
    
    float thit;
    ProceduralPrimitiveAttributes attr;
  
}

[shader("intersection")]
void MyIntersectionShader_SignedDistancePrimitive()
{
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
    SignedDistancePrimitive::Enum primitiveType = (SignedDistancePrimitive::Enum) l_aabbCB.primitiveType;

    float thit;
    ProceduralPrimitiveAttributes attr;

    if (RaySignedDistancePrimitiveTest(localRay, primitiveType, thit, attr, l_materialCB.stepScale))
    {
        PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit, /*hitKind*/ 0, attr);
    }
 
}



bool isEmpty(CSGNode csgStack[15], int nodePointer) {
    if (nodePointer <= -1) {
        return true;
    }
    return false;
}


void Push(inout CSGNode csgStack[15], inout int nodePointer, CSGNode node) {
    nodePointer += 1;
    csgStack[nodePointer] = node;
}

CSGNode Pop(inout CSGNode csgStack[15], inout int nodePointer) {
    CSGNode popped = csgStack[nodePointer];
    nodePointer -= 1;
    return popped;
}


void CSGCombine(in int operation, in intersectionInterval left, in intersectionInterval right, inout float tmin, inout float tmax, inout float3 normal, inout bool hit) {
  
    if (operation == 0) {
        if (left.hit && right.hit) {
            //union
            //get smallest and largest values over all intersections -- will need to record whether there were intersections for the subtrees
            tmin = min(left.tmin, right.tmin);
            tmax = max(left.tmax, right.tmax);
            if (tmin == left.tmin) {
                normal = left.normal;
            }
            else {
                normal = right.normal;
            }
            hit = true;
        }
        //else we don't intersect one of the subtrees
        else {
            if (right.hit) {
                tmin = right.tmin;
                tmax = right.tmax;
                normal = right.normal;
                hit = true;
            }
            else if(left.hit){
                tmin = left.tmin;
                tmax = left.tmax;
                normal = left.normal;
                hit = true;
            }
            else {
                tmin = -1;
                tmax = -1;
                normal = float3(0, 0, 0);
                hit = false;
            }
        }
    }




    else if (operation == 1) {
        //intersection
        if (left.hit && right.hit) {
            float e = max(left.tmin, right.tmin);
            float f = min(left.tmax, right.tmax);
            hit = true;
            tmin = min(e, f);
            tmax = max(e, f);

            if (tmin == e) {
                if (e == left.tmin) {
                    normal = left.normal;
                }
                else {
                    normal = right.normal;
                }
            }
        }
        else {
            tmin = -1;
            tmax = -1;
            normal = float3(0, 0, 0);
            hit = false;
        }
    }





    else {
        /*
    if (sphere_hit && hyp_hit) {
        intersections = float4(b_tmin, b_tmax, s_tmin, s_tmax);
        if(intersections.x < intersections.z){
            thit = intersections.x;
            attr = b_attr;
        }
        else if (intersections.w < intersections.y) {
            thit = intersections.w;
            attr.normal = -s_attr.normal;
        }
        else {
            return false;
        }

        return true;
        //return Intersection(intersections, thit, s_attr, b_attr, attr);
    }

    if (hyp_hit) {
        thit = t_hit;
        attr = b_attr;
        return true;
    }
    return false;
*/

    //difference
        if (right.hit && left.hit) {
            if (right.tmin < left.tmin) {
                tmin = right.tmin;
                tmax = left.tmin;
                normal = right.normal;
                hit = true;

            }
            else if (left.tmax < right.tmax) {
                tmin = left.tmax;
                tmax = right.tmax;
                normal = -left.normal;
                hit = true;

            }
            else {
                tmin = -1;
                tmax = -1;
                normal = float3(0, 0, 0);
                hit = false;
                
            }
        }
        else {
            if (right.hit) {
                tmin = right.tmin;
                tmax = right.tmax;
                normal = right.normal;
                hit = true;
            }
            else {
                tmin = -1;
                tmax = -1;
                normal = float3(0, 0, 0);
                hit = false;
            }
        }
    }

    
}
bool alternativeCSG(in Ray ray, out float thit, out ProceduralPrimitiveAttributes attr) {
    //tree is in post-order, just need to iterate the tree.

    intersectionInterval intersections[10];
    CSGNode current = csgTree[0];
    int i = 0;
    int depth = 1;
    uint num;
    uint stride;
    csgTree.GetDimensions(num, stride);
    while(i < 7) {
        //need to record depth
        if (current.boolValue == -1) {

            //trace a ray and find interesections - store
            float  tmin, tmax;
            float3 normal;
            Ray r;
            r.origin = ray.origin + current.translation;
            r.direction = ray.direction + current.translation;
            //r.direction = ray.direction + current.translation;
            bool hit = RayCSGGeometryIntervals(r, (AnalyticPrimitive::Enum)current.geometry, tmin, tmax, normal);
            intersectionInterval inter = { tmin, tmax, hit, normal };
            //store this interval in the intersections array at   our node's index.
            intersections[i] = inter;
        }
        else {
            //retrieve intersections, and store
            intersectionInterval left = intersections[i - 2*depth];
            intersectionInterval right = intersections[i - 1];
            float tmin, tmax;
            float3 normal;
            bool hit;
            //combine the nodes
            CSGCombine(current.boolValue, left, right, tmin, tmax, normal, hit);
            intersectionInterval inter = { tmin, tmax, hit, normal };
            //store this interval in the intersections array at our node's index.
            intersections[i] = inter;

        }
        i += 1;
        current = csgTree[i];
        if (i % 6 == 0) {
            depth += 1;
        }
    }
 

    intersectionInterval final = intersections[i-1];

    if (final.hit) {
        if (final.tmin > RayTMin()) {
            thit = final.tmin;
            attr.normal = final.normal;
            return true;
        }
        else if (final.tmax > RayTMin()) {
            thit = final.tmax;
            attr.normal = final.normal;
            return true;

        }
    }
    return false;
}

bool RayCSGIntersectionTest(in Ray ray, in CSGPrimitive::Enum csgPrimitive, out float thit, out ProceduralPrimitiveAttributes attr) {
    float minL = 0;
    float minR = 0;
    bool visitedNodes[7] = { 0, 0,0,0,0,0, 0 };
    intersectionInterval intersections[15];
    CSGNode csgStack[15];
    int nodePointer = -1;
    bool entry = true;
   // csgStack[0] = csgTree[0];
    
    CSGNode root = csgTree[0];
    while (!isEmpty(csgStack, nodePointer) || entry) {
        entry = false;
        //works
        while (root.leftNodeIndex != -1 && !visitedNodes[root.myIndex]) {

            Push(csgStack, nodePointer, csgTree[root.rightNodeIndex]);
            Push(csgStack, nodePointer, root);

            root = csgTree[root.leftNodeIndex];
        }


        if (root.leftNodeIndex == -1 && !visitedNodes[root.myIndex]) {
            if (root.rightNodeIndex != -1) {
                Push(csgStack, nodePointer, csgTree[root.rightNodeIndex]);
            }
            Push(csgStack, nodePointer, root);
        }
        //works
        root = Pop(csgStack, nodePointer);
        //
        if ((root.rightNodeIndex != -1) && (csgStack[nodePointer].parentIndex == root.myIndex)) {
            CSGNode right = Pop(csgStack, nodePointer);
            Push(csgStack, nodePointer, root);
            root = right;
            //return fal
        }else {
            //evaluate node
            //intersect root.
          
            int index = root.myIndex;
            //works - or at least runs.
            if (root.boolValue == -1) {
                //primitive node

                float  tmin, tmax;
                float3 normal;
                bool hit = RayCSGGeometryIntervals(ray, (AnalyticPrimitive::Enum)root.geometry, tmin, tmax, normal);
                //  float3 normal = attr.normal;
                      //intersect geometry
                intersectionInterval i = { tmin, tmax, hit, normal };
                //store this interval in the intersections array at our node's index.
                intersections[index] = i;
                visitedNodes[index] = true;

            }
            else {
              
                 //internal node
                 //get left node and right node intervals -- we know these have been stored since this is a postorder traversal
              
                //we certainly reach this.
                intersectionInterval left = intersections[root.leftNodeIndex];
                intersectionInterval right = intersections[root.rightNodeIndex];
                float tmin, tmax;
                float3 normal;
                bool hit;
                //combine the nodes
                CSGCombine(root.boolValue, left, right, tmin, tmax, normal, hit);

                //store the new tmin tmax value and normal at the node's index
                intersectionInterval interval = { tmin, tmax, hit, normal };
                intersections[index] = interval;
                visitedNodes[index] = true;

            }
        }
    }

    root = csgTree[0];
    intersectionInterval left = intersections[root.leftNodeIndex];
    intersectionInterval right = intersections[root.rightNodeIndex];
    float tmin, tmax;
    float3 normal;
    bool hit;

    CSGCombine(root.boolValue, left, right, tmin, tmax, normal, hit);
   
    /**
    intersectionInterval i = intersections[root.myIndex];
    float tmin = i.tmin;
    float tmax = i.tmax;
    float3 normal = i.normal;
    bool hit = i.hit*/
    
    if (hit) {
       if (tmin > RayTMin()) {
            thit = tmin;
            attr.normal = intersections[root.myIndex].normal;
            return true;

        }
        else if (tmax > RayTMin()) {
            thit = tmax;
            attr.normal = intersections[root.rightNodeIndex].normal;
            return true;

       }
        else {
           return false;
       }
    }
    return false;
}



[shader("intersection")]
void CSG_Intersection() {
    Ray localRay = GetRayInAABBPrimitiveLocalSpace();
   // AnalyticPrimitive::Enum primitiveType = (AnalyticPrimitive::Enum) l_aabbCB.primitiveType;

  CSGPrimitive::Enum primitiveType = (CSGPrimitive::Enum) l_aabbCB.primitiveType;
  // AnalyticPrimitive::Enum primitiveType = AnalyticPrimitive::Enum::Sphere;

    float thit;
    ProceduralPrimitiveAttributes attr;
   // if (RayCSGIntersectionTest(localRay, primitiveType, thit, attr)) {
    if (alternativeCSG(localRay, thit, attr)) {
    PrimitiveInstancePerFrameBuffer aabbAttribute = g_AABBPrimitiveAttributes[l_aabbCB.instanceIndex];
        attr.normal = mul(attr.normal, (float3x3) aabbAttribute.localSpaceToBottomLevelAS);
        attr.normal = normalize(mul((float3x3) ObjectToWorld3x4(), attr.normal));

        ReportHit(thit, 0, attr);
    }
    //do a test based on the CSG tree.
    //look up ways to decompose the recursive structure of the CSG tree.
}
#endif // RAYTRACING_HLSL